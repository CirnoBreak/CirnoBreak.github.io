<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my blog!</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://cirnobreak.github.io/"/>
  <updated>2020-03-11T11:34:29.661Z</updated>
  <id>https://cirnobreak.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode day11 - 将数组分成和相等的三个部分</title>
    <link href="https://cirnobreak.github.io/2020/03/11/leetcodeday11/"/>
    <id>https://cirnobreak.github.io/2020/03/11/leetcodeday11/</id>
    <published>2020-03-10T16:00:00.000Z</published>
    <updated>2020-03-11T11:34:29.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组  A，只有可以将其划分为三个和相等的非空部分时才返回  true，否则返回 false。</p><p>形式上，如果可以找出索引  i+1 &lt; j  且满足  (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1])  就可以将数组三等分。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：[0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：0 + 2 + 1 &#x3D; -6 + 6 - 7 + 9 + 1 &#x3D; 2 + 0 + 1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：3 + 3 &#x3D; 6 &#x3D; 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="遍历法"><a href="#遍历法" class="headerlink" title="遍历法"></a>遍历法</h2><p>由题意可知，要分成和相等的三部分，首先需要需要计算出整个的数组元素之和 sum，除以三得到每一部分的元素之和。有一种特殊情况是，数组之和为 0，可以分成大于或者等于和相等的部分。我们可以用声明一个变量 equalCount 来记录和相等的分组数，用于判断是否符合条件，tmp 用于记录临时的数组部分之和，用于判断是否符合等分条件。因此只需要在遍历的时候，判断当前部分累加之和是否等于 sum / 3，符合就给 equalCount + 1，直到最后，判断 equalCount 是否大于或者等于 3 即可（大于 3 的情况是数组之和 sum 为 0 的情况）。</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canThreePartsEqualSum = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 数组元素之和</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    sum += A[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数组部分和 tmp， 目标 target，符合条件的分组数 equalCount</span></span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="number">0</span>,</span><br><span class="line">    target = sum / <span class="number">3</span>,</span><br><span class="line">    equalCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">    tmp += A[j];</span><br><span class="line">    <span class="comment">// 如果符合条件，equalCount + 1，并清空数组的部分和tmp</span></span><br><span class="line">    <span class="keyword">if</span> (tmp === target) &#123;</span><br><span class="line">      tmp = <span class="number">0</span>;</span><br><span class="line">      equalCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> equalCount &gt;= <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/partition-array-into
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day10 - 二叉树的直径</title>
    <link href="https://cirnobreak.github.io/2020/03/10/leetcodeday10/"/>
    <id>https://cirnobreak.github.io/2020/03/10/leetcodeday10/</id>
    <published>2020-03-09T16:00:00.000Z</published>
    <updated>2020-03-10T10:04:02.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p>示例 :<br>给定二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>返回  3, 它的长度是路径 [4,2,1,3] 或者  [5,2,1,3]。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><p>本题的核心就是寻找二叉树左子树的最大深度和右子树的最大深度之和加上根节点(1)，可以拆分为不断遍历左右子树，通过回溯（自底向上）累加（空的时候为 0， 存在的时候加 1）得到当前节点的左右子树深度，并取最大值，可以参考<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/shi-pin-jie-shi-di-gui-dai-ma-de-yun-xing-guo-chen/" target="_blank" rel="noopener">link</a>的 ppt。</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 路径长度初始值</span></span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">depth</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 没有左/右子树时返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="keyword">const</span> leftChildNum = depth(node.left);</span><br><span class="line">    <span class="comment">// 遍历右子树</span></span><br><span class="line">    <span class="keyword">const</span> rightChildNum = depth(node.right);</span><br><span class="line">    <span class="comment">// 取路径最大值赋值给ans</span></span><br><span class="line">    ans = <span class="built_in">Math</span>.max(ans, leftChildNum + rightChildNum);</span><br><span class="line">    <span class="comment">// 取当前节点的左右子树中最长的路径，往上一步(+1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(leftChildNum, rightChildNum) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  depth(root);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/diameter-of-binary-t
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day09 - 买卖股票的最佳时机</title>
    <link href="https://cirnobreak.github.io/2020/03/09/leetcodeday09/"/>
    <id>https://cirnobreak.github.io/2020/03/09/leetcodeday09/</id>
    <published>2020-03-08T16:00:00.000Z</published>
    <updated>2020-03-09T14:28:27.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h2><p>暴力枚举比较简单，就是一直与之前的天数做减法运算，与临时变量 max 做对比，存放更大的值。</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放最大值的临时变量</span></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; prices.length; j++) &#123;</span><br><span class="line">      <span class="comment">// 求差值</span></span><br><span class="line">      <span class="keyword">const</span> delta = prices[j] - prices[i];</span><br><span class="line">      <span class="comment">// 判断是否为当前最大值</span></span><br><span class="line">      <span class="keyword">if</span> (delta &gt; max) &#123;</span><br><span class="line">        max = delta;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><p>只需通过一次遍历，每一天记录当天以及之前的买入价最低点和当天为止的最大利润。<br>使用 minPrice 存放当天及之前的最低点价格，初始为无限大确保能在对比是赋值更小的值。<br>使用 maxPrice 存放最大利润，如果当天价格没达到最低点，则计算当天与最低点的差值，并且与当前的 maxPrice 作比较，取两者较大值作为下一天的临时最大利润。</p><p>参考其中一个题解的动图 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/gu-piao-wen-ti-python3-c-by-z1m/" target="_blank" rel="noopener">link</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.leetcode-cn.com/4eaadab491f2bf88639d66c9d51bb0115e694ae08d637841ac18172b631cb21f-0121.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 价格最低点和最大利润</span></span><br><span class="line">  <span class="keyword">let</span> minPrice = <span class="literal">Infinity</span>,</span><br><span class="line">    maxPrice = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">      <span class="comment">// 如果当天价格比最低点要小，把当天价格赋值给最低点</span></span><br><span class="line">      minPrice = prices[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 取出当天价格与最低点的差值与临时最大利润做对比，取出两者最大值作为新的临时最大利润</span></span><br><span class="line">      maxPrice = <span class="built_in">Math</span>.max(prices[i] - minPrice, maxPrice);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxPrice;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day08 - 零钱兑换</title>
    <link href="https://cirnobreak.github.io/2020/03/08/leetcodeday08/"/>
    <id>https://cirnobreak.github.io/2020/03/08/leetcodeday08/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2020-03-08T12:01:23.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题涉及到动态规划，由于本人没接触过动态规划相关的，理解起来比较困难，等学习相关知识后再补充，下面简单说下代码思路，主要是参考 <a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" target="_blank" rel="noopener">link</a> 的迭代解法。</p><p>思路参考下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.leetcode-cn.com/b4e6cf1bb8e2284bfc01dfef6c1a60c19f9c78238061b65370ccc01822161e83.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从0开始一直到amount一直分解问题。<br>dp[i] = x 表示当前目标金额为i时，至少需要 x 枚硬币。<br>数组初始化为 amount + 1 是因为凑成 amount 枚硬币最多只能等于 amount（全用1元硬币的情况），所以初始为 amount + 1 相当于初始化为正无穷，便于后续取最小值。</p><p><strong>代码:</strong></p><p>```javascript<br>/**</p><ul><li><p>@param {number[]} coins</p></li><li><p>@param {number} amount</p></li><li><p>@return {number}</p></li><li><p>/<br>var coinChange = function(coins, amount) {<br>if (amount === 0) {<br>  return 0;<br>}<br>const dp = Array(amount + 1).fill(Infinity);<br>dp[0] = 0;<br>for (let i = 1; i &lt; dp.length; i++) {<br>  for (let j = 0; j &lt; coins.length; j++) {</p><pre><code>if (i - coins[j] &gt;= 0) {  dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);}</code></pre><p>  }<br>}</p><p>return dp[dp.length - 1] === Infinity ? -1 : dp[dp.length - 1];<br>};</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/&quot; target
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day07 - 队列的最大值</title>
    <link href="https://cirnobreak.github.io/2020/03/07/leetcodeday07/"/>
    <id>https://cirnobreak.github.io/2020/03/07/leetcodeday07/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-08T11:45:34.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请定义一个队列并实现函数 <strong>max_value</strong> 得到队列里的最大值，要求函数<strong>max_value</strong>、<strong>push_back</strong> 和 <strong>pop_front</strong> 的均摊时间复杂度都是O(1)。</p><p>若队列为空，<strong>pop_front</strong> 和 <strong>max_value</strong> 需要返回 -1</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>初始化两个队列，原始队列 queue ，就是正常的进队出队，另一个是辅助数组 deque ，存放最大值和小于最大值的值(降序排序)。</p><ol><li>进队(push_back)时，当前值 push 进原始队列 queue，同时拿当前值与辅助队列最后一个值进行对比，如果比最后一个值大，删掉最后一个值，继续上述操作直到数组为空或者找到比当前值大的值，push进辅助队列；如果开始就比当前值大或者开始 deque就为空，push 进deque。辅助队列主要是为了方便取最大值和pop_front的时候假如删除最大值可以保证取到下一轮的最大值。</li><li>出队(pop_front)时，直接删除原始队列 queue的第一个值即可，同事确保第一个值是否与 辅助队列 deque第一个值相等，如果相等，同时删掉 deque 的第一个值。</li><li>取最大值 max_value，根据上述可以知道直接取辅助队列 deque 第一个值即可，辅助队列为空时返回-1。</li></ol><p>参考 leetcode其中一个题解的动图 <a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/ru-he-jie-jue-o1-fu-za-du-de-api-she-ji-ti-by-z1m/" target="_blank" rel="noopener">link</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.leetcode-cn.com/9d038fc9bca6db656f81853d49caccae358a5630589df304fc24d8999777df98-fig3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>代码:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MaxQueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 原始队列，只处理进队出队</span></span><br><span class="line">  <span class="keyword">this</span>.queue = [];</span><br><span class="line">  <span class="comment">// 辅助队列，存放最大值和较大值(降序排序)</span></span><br><span class="line">  <span class="keyword">this</span>.deque = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MaxQueue.prototype.max_value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.deque.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.deque[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MaxQueue.prototype.push_back = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 直接向原始队列存值</span></span><br><span class="line">  <span class="keyword">this</span>.queue.push(value);</span><br><span class="line">  <span class="comment">// 从辅助队列末尾开始对比，删掉比当前值小的值</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">this</span>.deque.length &amp;&amp; <span class="keyword">this</span>.deque[<span class="keyword">this</span>.deque.length - <span class="number">1</span>] &lt; value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deque.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 往辅助队列存值</span></span><br><span class="line">  <span class="keyword">this</span>.deque.push(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MaxQueue.prototype.pop_front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">    <span class="comment">// 删掉原始队列第一个值</span></span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">this</span>.queue.shift();</span><br><span class="line">    <span class="comment">// 如果辅助队列第一个值跟当前值相等，删掉辅助队列第一个值</span></span><br><span class="line">    <span class="keyword">if</span> (val === <span class="keyword">this</span>.deque[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deque.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MaxQueue()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.max_value()</span></span><br><span class="line"><span class="comment"> * obj.push_back(value)</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.pop_front()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/dui-lie-de-zui-da-zh
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day06 - 和为s的连续正数序列</title>
    <link href="https://cirnobreak.github.io/2020/03/06/leetcodeday06/"/>
    <id>https://cirnobreak.github.io/2020/03/06/leetcodeday06/</id>
    <published>2020-03-05T16:00:00.000Z</published>
    <updated>2020-03-06T15:34:49.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p>[<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/]" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/]</a>(<a href="https://leetcode-cn.com/problems/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/</a><br>he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h2><p>暴力枚举的思路比较简单，注意遍历索引上限为target / 2向下取整即可。</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findContinuousSequence = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; target / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; target; j++) &#123;</span><br><span class="line">      sum += j;</span><br><span class="line">      <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> newArr = <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Array</span>(j - i</span>)).<span class="params">fill</span>(<span class="params"><span class="number">0</span></span>).<span class="params">map</span>(<span class="params">(v, index</span>) =&gt;</span> i + index + <span class="number">1</span>);</span><br><span class="line">        arr.push(newArr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口简单来说就是两个指针所围成的区域，而两个指针通过移动会引起这个范围变动，从而引起这个范围(窗口)滑动，即滑动窗口。<br>引用一下 leetcode 上一个题解的图 <a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/xiang-jie-hua-dong-chuang-kou-fa-qiu-gen-fa-jian-g/" target="_blank" rel="noopener">link</a>:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.leetcode-cn.com/b7bbf8306beaf1f05af3f46d33846a9f54543d74894ddcf81bf3e1e712dbabce-image.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.leetcode-cn.com/652fac6fe71a55076fad3550487de0574616521e0e7ea93d96e0694f0afda358-image.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>首先声明两个指针 i j 分别负责左右边界，sum 记录 i 到 j 之间的和，arr 用于存储符合条件的数组集。</p><ol><li>当 sum &lt; target时，右边界指针向右移动，并且 sum 加上有边界指针右移一位的值。 </li><li>当 sum &gt; target时，左边界指针向右移动，并且 sum 减去当前左边界指针的值。</li><li>当 sum === target，把符合的结果集存到arr，并且 sum 减去左边界指针的值，左边界指针向右移动。</li></ol><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findContinuousSequence = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 左边界指针从1开始，右边界指针为2，所以初始 sum 值为3</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>,</span><br><span class="line">    j = <span class="number">2</span>,</span><br><span class="line">    sum = <span class="number">3</span>,</span><br><span class="line">    arr = [];</span><br><span class="line">  <span class="comment">// 从头开始遍历，因为 (target / 2) + (target / 2 + 1)必然是大于 target的，所以 i 不超过 target / 2</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= (target / <span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">      <span class="comment">// 右边界指针右移</span></span><br><span class="line">      sum += (j + <span class="number">1</span>);</span><br><span class="line">      j++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">      <span class="comment">// 左边界指针右移</span></span><br><span class="line">      sum -= i;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 存放结果集，左边界指针右移</span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Array</span>((j + <span class="number">1</span></span>) - <span class="params">i</span>)).<span class="params">fill</span>(<span class="params"><span class="number">0</span></span>).<span class="params">map</span>(<span class="params">(v, index</span>) =&gt;</span> i + index);</span><br><span class="line">      arr.push(res)</span><br><span class="line">      sum -= i;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;[&lt;a href=&quot;https://leetcode-cn.com/problems/he-wei-sde-lian-xu-
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day05 - 分糖果 II</title>
    <link href="https://cirnobreak.github.io/2020/03/05/leetcodeday05/"/>
    <id>https://cirnobreak.github.io/2020/03/05/leetcodeday05/</id>
    <published>2020-03-04T16:00:00.000Z</published>
    <updated>2020-03-05T13:46:29.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode-cn.com/problems/distribute-candies-to-people/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distribute-candies-to-people/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>排排坐，分糖果。</p><p>我们买了一些糖果 <strong>candies</strong>，打算把它们分给排好队的 <strong>n = num_people</strong> 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 <strong>n</strong> 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 <strong>n + 1</strong> 颗糖果，第二个小朋友 <strong>n + 2</strong> 颗，依此类推，直到给最后一个小朋友 <strong>2 * n</strong> 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 <strong>num_people</strong>、元素之和为 <strong>candies</strong> 的数组，以表示糖果的最终分发情况（即 <strong>ans[i]</strong> 表示第 i 个小朋友分到的糖果数）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candies &#x3D; 7, num_people &#x3D; 4</span><br><span class="line">输出：[1,2,3,1]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] +&#x3D; 1，数组变为 [1,0,0,0]。</span><br><span class="line">第二次，ans[1] +&#x3D; 2，数组变为 [1,2,0,0]。</span><br><span class="line">第三次，ans[2] +&#x3D; 3，数组变为 [1,2,3,0]。</span><br><span class="line">第四次，ans[3] +&#x3D; 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candies &#x3D; 10, num_people &#x3D; 3</span><br><span class="line">输出：[5,2,3]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] +&#x3D; 1，数组变为 [1,0,0]。</span><br><span class="line">第二次，ans[1] +&#x3D; 2，数组变为 [1,2,0]。</span><br><span class="line">第三次，ans[2] +&#x3D; 3，数组变为 [1,2,3]。</span><br><span class="line">第四次，ans[0] +&#x3D; 4，最终数组变为 [5,2,3]。</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h2><p>这道题比较简单，只需要记录好每次要分的糖果数即可，每分一次减一次剩余糖果数。注意分到最后一个小朋友的时候的数量肯定是小于等于剩余糖果数，所以简单的处理方式就是每次分都判断一下当前剩余的糖果数跟要分的糖果数哪个更少就分哪个即可。</p><p><strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">candies</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">num_people</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> distributeCandies = <span class="function"><span class="keyword">function</span> (<span class="params">candies, num_people</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化数组</span></span><br><span class="line">  <span class="keyword">const</span> arr = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: num_people &#125;).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 每次要分的糖果数</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (candies != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// i % num_people 用于获取当前分到的小朋友的下标</span></span><br><span class="line">    <span class="comment">// 由于要判断是否分到最后一个小朋友，所以这里判断要分的糖果数和剩下的糖果数哪个数量更少，就分哪个</span></span><br><span class="line">    arr[i % num_people] += <span class="built_in">Math</span>.min(i, candies)</span><br><span class="line">    candies -= <span class="built_in">Math</span>.min(i, candies)</span><br><span class="line">    <span class="comment">// 新一轮分糖果开始，要分的糖果数量 + 1</span></span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/distribute-candies-t
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day04 - 腐烂的橘子</title>
    <link href="https://cirnobreak.github.io/2020/03/04/leetcodeday04/"/>
    <id>https://cirnobreak.github.io/2020/03/04/leetcodeday04/</id>
    <published>2020-03-03T16:00:00.000Z</published>
    <updated>2020-03-06T14:45:06.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotting-oranges/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><p><strong>示例 1</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt="示例1" title="">                </div>                <div class="image-caption">示例1</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><ol><li>indexQueue 用于存放感染的橘子的下标，freshNum 记录新鲜的橘子数量， mins 记录感染的分钟数。</li><li>首先遍历一遍 grid 数组，找出所有感染的橘子(2)的下标[i, j]，存放到 indexQueue 数组，供 BFS 使用，同时记录新鲜橘子的数量。</li><li>开始遍历 indexQueue，每次取出 indexQueue 第一个对应的值的下标，开始感染(四个方向都感染)。如果遇到新鲜的橘子，把该橘子的下标存进新的队列 newIndexQueue 提供后续遍历感染并把对应的值赋值为2，同时新鲜橘子的数量 - 1，一轮结束 mins + 1，把 newIndexQueue 赋值给indexQueue，开始新一轮的感染。</li><li>最后，如果还有新鲜的橘子(freshNum &gt; 0)，返回 -1，否则返回感染过程的分钟数 mins。</li></ol><p>引用一下其中一个 leetcode 题解的动图 <a href="https://leetcode-cn.com/problems/rotting-oranges/solution/yan-du-you-xian-sou-suo-python3-c-by-z1m/" target="_blank" rel="noopener">link</a>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.leetcode-cn.com/aec044437ac27b8e23ba0d8f07daac230e6e0c0671fcd6a68f8884b991b4e1cf-0994.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> orangesRotting = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始的感染橘子下标队列</span></span><br><span class="line">  <span class="keyword">let</span> indexQueue = [];</span><br><span class="line">  <span class="comment">// 新鲜橘子数量</span></span><br><span class="line">  <span class="keyword">let</span> freshNum = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 感染的分钟数</span></span><br><span class="line">  <span class="keyword">let</span> mins = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历橘子二维数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">      <span class="comment">// 把感染橘子的下标存到 indexQueue</span></span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">2</span>) &#123;</span><br><span class="line">        indexQueue.push([i, j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 记录新鲜橘子数量</span></span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">        freshNum++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (indexQueue.length &gt; <span class="number">0</span> &amp;&amp; freshNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 下一轮的indexQueue</span></span><br><span class="line">    <span class="keyword">let</span> newIndexQueue = [];</span><br><span class="line">    <span class="keyword">while</span> (indexQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> badOrangeIndex = indexQueue.shift();</span><br><span class="line">      <span class="comment">// 当前橘子感染的橘子数</span></span><br><span class="line">      <span class="keyword">let</span> curInfectNum = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 取下标</span></span><br><span class="line">      <span class="keyword">const</span> [r, c] = badOrangeIndex;</span><br><span class="line">      <span class="comment">// 往上感染</span></span><br><span class="line">      <span class="keyword">if</span> (r &gt; <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] === <span class="number">1</span>) &#123;</span><br><span class="line">        grid[r - <span class="number">1</span>][c] = <span class="number">2</span>;</span><br><span class="line">        curInfectNum++;</span><br><span class="line">        newIndexQueue.push([r - <span class="number">1</span>, c])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 往左感染</span></span><br><span class="line">      <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; grid[r][c - <span class="number">1</span>] === <span class="number">1</span>) &#123;</span><br><span class="line">        grid[r][c - <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        curInfectNum++;</span><br><span class="line">        newIndexQueue.push([r, c - <span class="number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 往下感染</span></span><br><span class="line">      <span class="keyword">if</span> (r &lt; grid.length - <span class="number">1</span> &amp;&amp; grid[r + <span class="number">1</span>][c] === <span class="number">1</span>) &#123;</span><br><span class="line">        grid[r + <span class="number">1</span>][c] = <span class="number">2</span>;</span><br><span class="line">        curInfectNum++;</span><br><span class="line">        newIndexQueue.push([r + <span class="number">1</span>, c])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 往右感染</span></span><br><span class="line">      <span class="keyword">if</span> (c &lt; grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; grid[r][c + <span class="number">1</span>] === <span class="number">1</span>) &#123;</span><br><span class="line">        grid[r][c + <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        curInfectNum++;</span><br><span class="line">        newIndexQueue.push([r, c + <span class="number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 减少新鲜橘子数量</span></span><br><span class="line">      freshNum -= curInfectNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一轮结束</span></span><br><span class="line">    mins++;</span><br><span class="line">    <span class="comment">// 准备开始下一轮遍历</span></span><br><span class="line">    indexQueue = newIndexQueue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (freshNum !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mins;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotting-oranges/&quot; ta
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day03 - 合并排序的数组</title>
    <link href="https://cirnobreak.github.io/2020/03/03/leetcodeday03/"/>
    <id>https://cirnobreak.github.io/2020/03/03/leetcodeday03/</id>
    <published>2020-03-02T16:00:00.000Z</published>
    <updated>2020-03-05T13:40:36.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sorted-merge-lcci/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化  A 和 B 的元素数量分别为  m 和 n。</p><p>示例:</p><p>输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">B &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="api-法"><a href="#api-法" class="headerlink" title="api 法"></a>api 法</h2><p>api 法比较简单，就是直接把 A 数组删掉从下标 m - 1 开始的所有元素，然后 B 数组截取前 n 个元素后插入 A 数组，最后对 A 数组进行一次排序。</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">B</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify A in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">A, m, B, n</span>) </span>&#123;</span><br><span class="line">  A.splice(m, A.length - m, ...B.slice(<span class="number">0</span>, n));</span><br><span class="line">  A.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>题目给出的条件是，A 的末端有足够的缓冲空间容纳 B，由此可以初始化两个指针，位置分别指向第 m n 位置，也就是下标为 m - 1 和 n - 1，从数组 A 末端开始填充数据，即一直给数组 A 下标为 m + n - 1 赋值两个指针对应下标的最大值。</p><p>举例:</p><p>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6], n = 3 时</p><p>第一轮， A[3 - 1] 与 B[3 - 1] 比较，此时 A[3 - 1] &lt; B[3 - 1]，把 B[3 - 1]的值赋值到 A[3 + 3 - 1]，B 指针对应下标 - 1<br>第二轮, A[3 - 1] 与 B[2 - 1] 比较，此时 A[3 - 1] &lt; B[2 - 1]，把 B[3 - 1]的值赋值到 A[3 + 2 - 1]，B 指针对应下标 - 1<br>第三轮, A[3 - 1] 与 B[1 - 1] 比较，此时 A[3 - 1] &gt; B[1 - 1]，把 A[3 - 1]的值赋值到 A[3 + 1 - 1]，A 指针对应下标 - 1<br>…</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">A, m, B, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 A 和 B 数组指针的下标和赋值位置下标</span></span><br><span class="line">  <span class="keyword">let</span> mIndex = m - <span class="number">1</span>,</span><br><span class="line">    nIndex = n - <span class="number">1</span>,</span><br><span class="line">    cur = m + n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (mIndex &gt;= <span class="number">0</span> || nIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mIndex === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 此时 A 数组已经挪完，B数组继续往前挪</span></span><br><span class="line">      A[cur] = B[nIndex];</span><br><span class="line">      nIndex--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nIndex === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 此时 B 数组已经挪完，A数组继续往前挪</span></span><br><span class="line">      A[cur] = A[mIndex];</span><br><span class="line">      mIndex--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[mIndex] &gt; B[nIndex]) &#123;</span><br><span class="line">      <span class="comment">// 此时 A 数组指针对应的值比 B 数组指针的值大，赋值后 A 指针往前挪</span></span><br><span class="line">      A[cur] = A[mIndex];</span><br><span class="line">      mIndex--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 此时 B 数组指针对应的值大于或者等于 A 数组指针的值，赋值后 B 指针往前挪</span></span><br><span class="line">      A[cur] = B[nIndex];</span><br><span class="line">      nIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一轮结束后赋值的下标往前挪</span></span><br><span class="line">    cur--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotting-oranges/&quot; ta
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day02 - 反转链表</title>
    <link href="https://cirnobreak.github.io/2020/03/02/leetcodeday02/"/>
    <id>https://cirnobreak.github.io/2020/03/02/leetcodeday02/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2020-03-05T13:40:22.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>反转一个单链表。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h2><p>遍历整个链表，借助变量 pre 记录前驱结点(初始为 null)，把当前结点(current)的 next 连接到 pre，即 current.next = pre。</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义单链表</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 链表为空或者只有一个元素时直接返回head</span></span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化，先从head开始遍历，由于链表head的前驱为null，所以pre初始时为null</span></span><br><span class="line">  <span class="keyword">let</span> current = head,</span><br><span class="line">    pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    <span class="comment">// 拷贝一份当前结点的后继结点</span></span><br><span class="line">    <span class="keyword">const</span> next = current.next;</span><br><span class="line">    <span class="comment">// 把当前结点的后继结点连接到前驱结点(反转)</span></span><br><span class="line">    <span class="comment">// 比如, null-&gt;head-&gt;next 变成了 null&lt;-head</span></span><br><span class="line">    current.next = pre;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始:</span></span><br><span class="line"><span class="comment">     * pre = null, current = null&lt;-head</span></span><br><span class="line"><span class="comment">     * 下一回:</span></span><br><span class="line"><span class="comment">     * pre = null&lt;-head，current = head.next</span></span><br><span class="line"><span class="comment">     * 再下一回</span></span><br><span class="line"><span class="comment">     * pre = null&lt;-head&lt;-head.next，current = head.next.next</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 把当前结点赋值到前驱结点，准备下一次链表反转</span></span><br><span class="line">    pre = current;</span><br><span class="line">    <span class="comment">// 把反转前的 current.next 的备份作为当前结点，准备下一次链表反转</span></span><br><span class="line">    current = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>递归解法代码实现比较简单，就是通过递归，直到触发结束条件，然后从尾部一直反转连接到头部。<br>也就是从链表尾部开始，每一次都先把自己与后继结点连接断掉，然后后继结点指向自己，直到连接到头部为止。</p><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归结束条件</span></span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> next = head.next,</span><br><span class="line">    newList = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// head断开与后继结点的连接</span></span><br><span class="line">  head.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 后继结点的后继结点连接到head</span></span><br><span class="line">  next.next = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode day01 - 用队列实现栈</title>
    <link href="https://cirnobreak.github.io/2020/03/01/leetcodeday01/"/>
    <id>https://cirnobreak.github.io/2020/03/01/leetcodeday01/</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-03-05T13:39:55.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h1><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-stack-using-queues/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>使用队列实现栈的下列操作：</p><p>push(x) – 元素 x 入栈<br>pop() – 移除栈顶元素<br>top() – 获取栈顶元素<br>empty() – 返回栈是否为空</p><p>注意:</p><p>你只能使用队列的基本操作– 也就是  push to back, peek/pop from front, size, 和  is empty  这些操作是合法的。<br>你所使用的语言也许不支持队列。  你可以使用 list 或者 deque（双端队列）来模拟一个队列  , 只要是标准的队列操作即可。<br>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="简单解法-非-api"><a href="#简单解法-非-api" class="headerlink" title="简单解法(非 api)"></a>简单解法(非 api)</h2><p>用一个数组模拟栈(LIFO)，数组末尾为栈顶，数组头为栈底。</p><ol><li>实现 top 只需获取数组末尾元素。</li><li>实现 push 只需在数组末尾添加元素。</li><li>pop 的实现，首先是获取数组最后一个元素，并且需要对数组长度减一来实现数组删除最后一个元素的操作。</li><li>实现 empty 只需要判断数组是否为空即可。</li></ol><p><strong>代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MyStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.stack = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把元素 x 压入栈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length] = x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移出栈顶元素并且返回该元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ele = <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">this</span>.stack.length = <span class="keyword">this</span>.stack.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ele;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接获取栈顶元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回栈是否为空的布尔值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.stack.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-stack-usin
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cirnobreak.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[译]如何使用React Hooks获取数据?</title>
    <link href="https://cirnobreak.github.io/2019/03/14/hooksfetchdata/"/>
    <id>https://cirnobreak.github.io/2019/03/14/hooksfetchdata/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2020-03-07T14:02:30.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接: <a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">How to fetch data with React Hooks?</a><br>原文作者: <a href="https://www.robinwieruch.de/" target="_blank" rel="noopener">RWieruch</a></p></blockquote><p>在这篇教程中，我们会让你明白如何通过<a href="https://reactjs.org/docs/hooks-state.html" target="_blank" rel="noopener">state</a>和<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener">effect</a>这两个 hooks 来<code>获取数据</code>。我们会使用广为人知的<a href="https://hn.algolia.com/api" target="_blank" rel="noopener">Hacker News API</a>来获取科技世界的流行文章。你也可以实现你的<code>custom hook(自定义钩子)</code>,它可以在你的应用程序任何地方复用，或者发布到 npm 上作为一个独立的 npm 包。</p><p>如果你不知道这些 React 新特性，你也可以阅读<a href="https://www.robinwieruch.de/react-hooks/" target="_blank" rel="noopener">introduction to React Hooks</a>这篇文章。如果你想查看这个项目代码，点击这个<a href="https://github.com/the-road-to-learn-react/react-hooks-introduction" target="_blank" rel="noopener">Github 仓库</a>的链接。</p><p><strong>NOTE</strong>: 在未来，React Hooks 不适合用于在 React 中获取数据。取而代之的是一个叫 Suspense 的新特性。尽管如此，文章以下内容仍然对于学习关于 state 跟 effect hooks 有帮助。</p><h1 id="使用-React-Hooks-获取数据"><a href="#使用-React-Hooks-获取数据" class="headerlink" title="使用 React Hooks 获取数据"></a>使用 React Hooks 获取数据</h1><p>如果你对 React 获取数据不熟悉，可以阅读<a href="https://www.robinwieruch.de/react-fetching-data/" target="_blank" rel="noopener">extensive data fetching in React article</a>，它会告诉你如何通过 React 的 class component 来获取数据、怎样使用<a href="https://www.robinwieruch.de/react-render-props-pattern/" target="_blank" rel="noopener">Render Props 组件</a>和<a href="https://www.robinwieruch.de/gentle-introduction-higher-order-components/" target="_blank" rel="noopener">高阶组件</a>来实现复用，还有它是怎样解决错误处理和加载 spinner 的。在这篇文章，我们会给你展示如何在函数式组件(functional component)中使用 React Hooks 来实现上述内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>App 组件展示了一个 items 列表(hits = Hacker News 文章)。状态和状态更新的函数来源于叫做<code>useState</code>的状态钩子，它负责管理我们将为 App 组件获取的数据的本地状态。表示 data 的初始状态是一个对象里面属性名为 hits 的空数组，目前没有任何人为 data 设置任何状态(state)。</p><p>我们将使用<a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a>来获取数据，但至于是否使用其他获取数据的库或者浏览器原生的 fetch API 将由你来决定。如果你没有安装 axios，你可以在命令行输入<code>npm install axios</code>，然后使用 effect hooks 来实现数据获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">      <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>名为 useEffect 的 effect hook，用于使用 axios 从 API 获取数据，并且使用 state hook 的更新函数(setData)把数据存放到组件内的本地 state。Promise resolving 会在 aysnc/await 中进行。</p><p>然而，当你运行你的应用程序时，你会陷入一个恶性循环。组件挂载(mount)的时候 effect hook 会运行，但组件更新(update)的时候会再次运行。它将一次又一次地获取数据。这是一个 bug 并且需要预防。<strong>我们只需要在组件挂载的时候获取数据。</strong>这就是为什么可以使用一个空数组作为 effect hook 的第二个参数，来避免组件更新的时候激活它，并且只在组件挂载的时候激活它的原因。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">      <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>第二个参数可以定义 hook 依赖的所有变量(在这个数组中分配)。如果其中一个参数改变，hook 会再次运行。如果数组内的变量为空，组件更新的时候 hook 不会运行，因为它不会去监听任何变量的变化。</p><p>还有最后一个问题。在代码中，我们使用 async/await 从第三方 API 获取数据。根据文档的描述，每一个使用 async 的函数注解都应该返回一个隐式 promise。*”async 函数声明定义一个异步函数，它返回一个 AsyncFunction 对象。异步函数是通过事件循环(event loop)异步操作的函数,它使用隐式 promise 返回结果。”<em>然而，一个 effect hook 它应该不返回任何东西或者返回一个简洁的函数。这就是为什么你会看到在开发者模式会有如下的 console log:*</em>07:41:22.910 index.js:1452 Warning: useEffect function must return a cleanup function or nothing. Promises and useEffect(async () =&gt; …) are not supported, but you can call an async function inside an effect.**。这就是为什么不允许直接在<code>useEffect</code>里面使用 async 函数的原因。我们换种方式在 effect hook 中使用 async 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>简单来说，就是使用 React Hooks 获取数据。如果你对错误处理、加载指示、如何触发表单数据获取，以及如何实现可复用的数据获取 hook 这些内容感兴趣，请继续阅读文章。</p><h1 id="如何以编程的方式-手动地触发-hook"><a href="#如何以编程的方式-手动地触发-hook" class="headerlink" title="如何以编程的方式/手动地触发 hook"></a>如何以编程的方式/手动地触发 hook</h1><p>太棒了，一旦组件挂载后，我们就可以获取到数据了。但是，如果我们输入某个字段来告诉 API 我们对哪个话题感兴趣呢？将”Redux”作为默认查询(query)，但关于”React”的话题呢？让我们来实现一个 input 元素(element)来使得某人可以获取除了”Redux”之外的话题的相关数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">            &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>此时，两个状态(state)是彼此独立的，但现在你希望将它们耦合起来，只通过输入字段指定的查询(query)来获取数据。通过以下修改，组件会在挂载后按照查询(query)获取所有相关文章。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>此时我们会发现少了一样东西: 当你尝试在在输入框输入一些东西的时候，你会发现，在组件挂载后触发的 effect hook 获取了数据之后，就不会再获取数据了。这是因为你在 effect hook 的把一个空数组作为第二个参数，而 effect hook 没有依赖的变量，所以它只在组件挂载的时候触发。然而，现在的 effect hook 需要依赖查询(query)。一旦查询(query)改变，数据请求应该再次触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [query]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>一旦你改变了输入框里面的值，数据就会重新获取。但这会引发另一个问题: 每输入一个字符都会触发数据获取请求。不如提供一个按钮，来手动触发 hook?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> [search, setSearch] = useState(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [query]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; setSearch(query)&#125;&gt;</span><br><span class="line">        Search</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>现在，我们使 effect hook 依赖于搜索(search)的状态，而不是每次输入都波动地改变查询(query)的状态。一旦用户点击了按钮，新的搜索(search)状态会被设置，并手动触发了 effect hook。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">  <span class="keyword">const</span> [search, setSearch] = useState(<span class="string">'redux'</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;search&#125;</span>`</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [search]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>此外，搜索(search)状态的初始值会被设置为与查询(query)状态相同的状态，因为组件也在挂载时获取数据，因此结果应该与输入框的值对应。然而，具有相似的查询(query)和搜索(search)状态会令人困惑。为何不把实际的 URL 设置为状态而不是设置为搜索(search)状态？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        type=<span class="string">"button"</span></span><br><span class="line">        onClick=&#123;() =&gt;</span><br><span class="line">          setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Search</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这是使用 effect hook 来获取隐式程序数据的情况。你可以决定 effect hook 取决于哪个状态。一旦你在点击或者在其他副作用的情况下设置状态，effect hook 会重新运行。在这种情况下，如果 URL 状态改变了，effect hook 会重新从 API 请求数据。</p><h1 id="使用-React-Hooks-实现加载指示器"><a href="#使用-React-Hooks-实现加载指示器" class="headerlink" title="使用 React Hooks 实现加载指示器"></a>使用 React Hooks 实现加载指示器</h1><p>让我们为数据获取请求引入一个加载指示器。它只是另一个由 state hook 管理的状态。loading 标志用于在 App 组件中呈现加载指示器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        type=<span class="string">"button"</span></span><br><span class="line">        onClick=&#123;() =&gt;</span><br><span class="line">          setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Search</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &#123;isLoading ? (</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;Loading ...&lt;/</span>div&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">              &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>在组件挂载或者 URL 状态改变的时候，一旦 effect hook 调用数据获取方法，加载(loading)状态就会被设置为 true。一旦请求完成，加载(loading)状态就会被再次设置为 false。</p><h1 id="使用-React-Hooks-进行错误处理"><a href="#使用-React-Hooks-进行错误处理" class="headerlink" title="使用 React Hooks 进行错误处理"></a>使用 React Hooks 进行错误处理</h1><p>那如何使用一个 React Hook 来进行数据获取时的错误处理？错误只是 state hook 的另一种初始状态。一旦错误(error)状态存在，App 组件会给用户渲染一个错误的反馈。当使用 async/await 的时候，通常使用 try/catch 块进行错误处理。你也可以在 effect hook 里面使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [isError, setIsError] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsError(<span class="literal">false</span>);</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        setData(result.data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        setIsError(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        type=<span class="string">"button"</span></span><br><span class="line">        onClick=&#123;() =&gt;</span><br><span class="line">          setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Search</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/</span>div&gt;&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isLoading ? (</span><br><span class="line">        &lt;div&gt;Loading ...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      ) : (</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">            &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>effect hook 每次运行的时候，错误(error)状态都会被重设一遍。这是非常有用的，因为在请求失败的时候，用户可能想要再次尝试获取，这时候应该重置错误。为了强制实现出错的情况，你可以把 URL 修改为一些无效的内容，然后检查一下错误信息是否成功显示。</p><h1 id="使用表单和-React-获取数据"><a href="#使用表单和-React-获取数据" class="headerlink" title="使用表单和 React 获取数据"></a>使用表单和 React 获取数据</h1><p>如何使用合适的表单来获取数据？到目前为止，我们有输入框和按钮的组合。一旦引入更多的输入元素，你可能会想要用表单元素来包裹它们。此外，表单还可以触发键盘上的”Enter”来触发按钮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;form</span><br><span class="line">        onSubmit=&#123;() =&gt;</span><br><span class="line">          setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;query&#125;</span><br><span class="line">          onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Search&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">      &#123;isError &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Something went wrong ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>但是现在点击提交按钮的时候，浏览器会重新加载，因为这是提交表单时浏览器的固有行为。为了防止这种默认行为，我们可以在 React 事件中调用一个函数。在 React 的 class component 也是这样实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;event =&gt; &#123;</span><br><span class="line">        doFetch();</span><br><span class="line"></span><br><span class="line">        event.preventDefault();</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;query&#125;</span><br><span class="line">          onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Search&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">      &#123;isError &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Something went wrong ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>现在，当你点击提交按钮的时候，浏览器也不会重新加载了。它和以前一样，但这次使用的是表单而不是原来的输入框和按钮的组合。你也可以在键盘上按上”Enter”触发。</p><h1 id="自定义一个数据获取-hook"><a href="#自定义一个数据获取-hook" class="headerlink" title="自定义一个数据获取 hook"></a>自定义一个数据获取 hook</h1><p>为了抽离一个数据获取的自定义 hook，将属于数据获取的所有内容，除了属于输入框的查询(query)状态，但包括加载指示器和错误处理的，移动到它自己的函数里。还要确保从 App 组件中使用函数返回所有必要的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useHackerNewsApi = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [isError, setIsError] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsError(<span class="literal">false</span>);</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        setData(result.data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        setIsError(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, isLoading, isError, doFetch &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，一个全新的 hook 可以再次在 App 组建中使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; data, isLoading, isError, doFetch &#125; = useHackerNewsApi();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span>...<span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，从<code>doFetch</code>函数外部传入 URL 状态:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useHackerNewsApi = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  useEffect(</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, isLoading, isError, doFetch &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; data, isLoading, isError, doFetch &#125; = useHackerNewsApi();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;form</span><br><span class="line">        onSubmit=&#123;event =&gt; &#123;</span><br><span class="line">          doFetch(</span><br><span class="line">            <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>,</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          event.preventDefault();</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;query&#125;</span><br><span class="line">          onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Search&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>初始状态也可以是通用的。简单地把它传递到新的自定义 hook:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(initialData);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [isError, setIsError] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsError(<span class="literal">false</span>);</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        setData(result.data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        setIsError(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, isLoading, isError, doFetch &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    data,</span><br><span class="line">    isLoading,</span><br><span class="line">    isError,</span><br><span class="line">    doFetch</span><br><span class="line">  &#125; = useDataApi(<span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span>, &#123;</span><br><span class="line">    hits: []</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;form</span><br><span class="line">        onSubmit=&#123;event =&gt; &#123;</span><br><span class="line">          doFetch(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">          event.preventDefault();</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;query&#125;</span><br><span class="line">          onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Search&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">      &#123;isError &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Something went wrong ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isLoading ? (</span><br><span class="line">        &lt;div&gt;Loading ...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      ) : (</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">            &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>这就是使用自定义 hook 获取数据的原因。hook 本身不知道任何跟 API 相关的内容。它接收外部的所有参数，并且只管理必要的状态，比如数据(data)、加载(loading)、错误(error)状态。它将执行请求，并且给组件返回数据。</p><h1 id="使用-Reducer-Hook-请求数据"><a href="#使用-Reducer-Hook-请求数据" class="headerlink" title="使用 Reducer Hook 请求数据"></a>使用 Reducer Hook 请求数据</h1><p>到目前为止，我们已经使用了各种 state hook 来管理获取到的数据 - 数据(data)、加载(loading)和错误(error)状态。然而，不知何故，所有的这些状态都是由它们自身的 state hook 管理的，并且联系在一起，因为它们关心的是同样的问题。如你所见，它们都是在数据获取函数中使用的。能表明它们联系在一起的表现是它们是一个接一个地使用的(比如: <code>setIsError</code>, <code>setIsLoading</code>)。让我们把这三个用 Reducer Hook 结合起来。</p><p>Reducer Hook 返回一个状态(state)对象和一个修改状态(state)对象的函数。这个叫做 dispatch 的函数，带有一个含有类型(type)跟可选的载荷(payload)的动作(action)。所有的这些信息，在实际的 reducer 函数中使用 action 中的可选载荷(payload)和类型(type)，实现从以前的状态(state)提取一个全新的状态(state)的动作。让我们来看看这在代码中是如何工作的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;</span><br><span class="line">  Fragment,</span><br><span class="line">  useState,</span><br><span class="line">  useEffect,</span><br><span class="line">  useReducer,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reducer Hook 将 reducer 函数和初始状态对象作为参数。在我们的例子中，数据(data)、加载(loading)和错误(error)状态的初始状态没有发生改变，但它们被聚合到一个由 reducer hook 管理的状态对象，而不是单独的一个 state hook。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_INIT'</span> &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_SUCCESS'</span>, <span class="attr">payload</span>: result.data &#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_FAILURE'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，当你获取数据的时候，dispatch 函数会把信息发送到 reducer 函数。使用 dispatch 函数发送对象需要有一个必要的<code>type</code>属性跟一个可选的<code>payload</code>属性。类型(type)告诉了 reducer 函数需要转换哪个状态(state)，reducer 还能从载荷(payload)中提取新的状态(state)。毕竟，我们只有三个状态转换:初始化获取进程、通知数据获取成功的结果、并通知数据获取错误的结果。</p><p>在自定义 hook 的末尾，像以前一样返回状态，因为我们有一个状态对象而不是独立的状态，状态对象返回的是一个被破坏的对象。这样，调用 useDataApi 这个自定义 hook 仍然可以访问<code>data</code>、<code>isLoading</code>、<code>isError</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, doFetch &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，同样重要的一点是，我们还没有实现 reducer 函数。它需要作用域三个不同的状态转化: <code>FETCH_INIT</code>、<code>FETCH_SUCCESS</code>、<code>FETCH_FAILURE</code>。每一个状态转换都需要返回一个新的状态(state)对象。让我们来看看如何使用 switch case 语句来实现这一点:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_INIT"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_SUCCESS"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_FAILURE"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reducer 函数可以通过参数访问当前状态和传入的操作。到目前为止，在 switch 里的 case 语句中，每个状态的转换只返回之前的状态。解构语句用于保持状态对象不可变 - 意味着状态(state)不能直接编译(mutated) - 执行最佳方案。现在，让我们覆盖一些当前状态返回的属性，以便在每次状态转换时修改状态:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_INIT"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        isLoading: <span class="literal">true</span>,</span><br><span class="line">        isError: <span class="literal">false</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_SUCCESS"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        isLoading: <span class="literal">false</span>,</span><br><span class="line">        isError: <span class="literal">false</span>,</span><br><span class="line">        data: action.payload</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_FAILURE"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        isLoading: <span class="literal">false</span>,</span><br><span class="line">        isError: <span class="literal">true</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，由 action 的 type 决定的每个状态转换都返回一个基于先前状态和可选的载荷(payload)的新状态。例如，在请求成功的情况下，载荷(payload)用于设置新状态对象的数据。</p><p>总之，Reducer Hook 确保了状态管理这一部分用自己的逻辑封装。通过提供 action 类型(type)和可选的载荷(payload)，你总会得到可预测的状态更改。另外，你永远不会遇到无效的状态。例如，以前你可能会意外地将<code>isLoading</code>和<code>isError</code>的状态设置为 true。在这种情况下，UI 应该显示什么？现在，由 reducer 函数定义的每个状态转换都会让另一个状态对象有效。</p><h1 id="在-Effect-Hook-中-中止数据获取"><a href="#在-Effect-Hook-中-中止数据获取" class="headerlink" title="在 Effect Hook 中,中止数据获取"></a>在 Effect Hook 中,中止数据获取</h1><p>在 React 中，即使组件已经卸载，但组件的状态仍会被设置，这是一个常见的问题。(比如: React Router 的导航)。我之前写过这个问题，它描述了<a href="https://www.robinwieruch.de/react-warning-cant-call-setstate-on-an-unmounted-component/" target="_blank" rel="noopener">如何防止在各种场景中为未挂载的组件设置状态</a>。让我们看看如何防止在自定义 hook 中为数据获取设置状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> didCancel = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: <span class="string">"FETCH_INIT"</span> &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!didCancel) &#123;</span><br><span class="line">          dispatch(&#123; <span class="attr">type</span>: <span class="string">"FETCH_SUCCESS"</span>, <span class="attr">payload</span>: result.data &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!didCancel) &#123;</span><br><span class="line">          dispatch(&#123; <span class="attr">type</span>: <span class="string">"FETCH_FAILURE"</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      didCancel = <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, doFetch &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个 Effect Hook 都会带有一个 clean up 函数，它会在组件卸载的时候执行。clean up 函数式 hook 返回的一个功能。在我们的例子中，我们使用一个名为<code>didCancel</code>的标记来让我们的数据获取逻辑知道组件的状态(已挂载/已卸载)。如果组件已经卸载，标记应该设置为<code>true</code>，这将导致在最终异步解决后无法设置组件状态。</p><p><em>Note: 实际上，数据获取并没有中止 - 这可以通过<a href="https://github.com/axios/axios#cancellation" target="_blank" rel="noopener">Axios Cancellation</a>来实现 - 但对于已卸载的组件，不再执行状态转换。由于 Axios Cancellation 在我看来并不是最好的 API，阻止状态设置的布尔值标记也能起到作用。</em></p><p>你已经了解了如何在 React 中使用 state 和 effect hook 进行数据获取了。如果你对在使用 render props 和高阶组件的 class component(和 functional component)中获取数据感兴趣，你可以阅读我在文章开头提及到的文章。此外，我希望本文对学习 React Hooks 以及在实际场景中使用它们有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接: &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to fetch data with Re
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://cirnobreak.github.io/categories/Javascript/"/>
    
    
      <category term="React" scheme="https://cirnobreak.github.io/tags/React/"/>
    
      <category term="Javascript" scheme="https://cirnobreak.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>对深浅拷贝的简单理解</title>
    <link href="https://cirnobreak.github.io/2019/02/27/jscopy/"/>
    <id>https://cirnobreak.github.io/2019/02/27/jscopy/</id>
    <published>2019-02-26T16:00:00.000Z</published>
    <updated>2020-03-07T14:02:32.192Z</updated>
    
    <content type="html"><![CDATA[<p>深浅拷贝在前端开发中是必然会踩的一个坑，也是面试常考题。至于深浅拷贝为何会存在，主要是跟 JavaScript 的数据类型以及一些历史遗留的问题有关，下面来简单了解下这两者的区别以及如何实现。</p><h1 id="为何需要深浅拷贝"><a href="#为何需要深浅拷贝" class="headerlink" title="为何需要深浅拷贝?"></a>为何需要深浅拷贝?</h1><p>首先，先从 JavaScript 的数据类型开始，在 JavaScript 中，有其中的内置类型，而这其中内置类型又分为两大类: 6 种原始类型(Boolean, Null, Undefined, Number, String, Symbol)和 Object。其中原始类型又叫基本类型，属于值类型，是按值访问的，因此可以操作保存在变量的实际的值；而 Object 属于引用类型，是按引用访问的，在操作对象的时候，实际上是操作对象的引用而不是对象的实际的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1; <span class="comment">// 5</span></span><br><span class="line">num2 = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1, num2); <span class="comment">// 5 3，指向不同数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1(); <span class="comment">// &#123;&#125;</span></span><br><span class="line">obj2.a = <span class="string">"ok"</span>; <span class="comment">// &#123; a: 'ok' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2); <span class="comment">// &#123; a: 'ok' &#125; &#123; a: 'ok' &#125;， 指向同一份数据</span></span><br></pre></td></tr></table></figure><p>可见，由于 Object 是引用类型，在吧 obj2 赋值给 obj1 的过程中，实际上，此时 obj1 跟 obj2 都指向了同一份数据(堆内存的同一块地址)，也就是说，在修改 obj2 的同时，也会对 obj1 造成影响。那我们要怎么样才能避免出现这样的问题?这时候就需要深/浅拷贝了。</p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>按字面上的意思来理解，浅拷贝就是浅层的拷贝，在实际上是只对第一层进行拷贝。随着 ES6 的到来，我们有非常简单的浅拷贝解决方案。</p><ol><li>使用 Object.assign()</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: <span class="string">"ok"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1); <span class="comment">// &#123; a: 'ok' &#125;</span></span><br><span class="line">obj2.b = <span class="string">"yes"</span>; <span class="comment">// &#123; a: 'ok', b: 'yes' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2); <span class="comment">// &#123; a: 'ok' &#125; &#123; a: 'ok', b: 'yes' &#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用扩展运算符(…)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: <span class="string">"ok"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1 &#125;;</span><br><span class="line">obj2.b = <span class="string">"yes"</span>; <span class="comment">// &#123; a: 'ok', b: 'yes' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2); <span class="comment">// &#123; a: 'ok' &#125; &#123; a: 'ok', b: 'yes' &#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>传统 for 循环解决方案</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowCopy = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> Ojbect.keys(obj)) &#123;</span><br><span class="line">    newObj = obj[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: <span class="string">"ok"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = shallowCopy(obj1);</span><br><span class="line">obj2.b = <span class="string">"yes"</span>; <span class="comment">// &#123; a: 'ok', b: 'yes' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2); <span class="comment">// &#123; a: 'ok' &#125; &#123; a: 'ok', b: 'yes' &#125;</span></span><br></pre></td></tr></table></figure><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>上面的例子由于对象都只有一层，所以使用浅拷贝，没什么问题，但万一对象变成了多层的时候，使用上述的方法都会出现问题，下面只举其中一个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1 &#125;;</span><br><span class="line">obj2.a.b.c = <span class="number">2</span>; <span class="comment">// &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2); <span class="comment">//  &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125; &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>那深拷贝又如何实现?</p><ol><li>简单粗暴的方式: 递归 + 浅拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(source) === <span class="string">"[object Object]"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(obj[i])) &#123;</span><br><span class="line">      target[i] = obj[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[i] = deepCopy(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = deepCopy(obj1);</span><br><span class="line">obj2.a.b.c = <span class="number">2</span>; <span class="comment">// &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2); <span class="comment">//  &#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125; &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>这种方法会存在跟数组以及 ES6 相关 api 的问题，同时递归遇到很深的层次以及循环引用也会出现问题，由于只是简单实现就不考虑了。</p><ol start="2"><li>JSON API 法</li></ol><p>这种方法比较简单，只需要一行代码即可:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br><span class="line">obj2.a.b.c = <span class="number">2</span>; <span class="comment">// &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2); <span class="comment">//  &#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125; &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>这种方法看起来特别简单，但存在局限性: JSON.stringify 在序列化的时候，会忽略值为<code>undefined、symbol</code>的整个键值对，并且不能序列化函数以及不能解决循环引用的对象。</p><ol start="3"><li>MessageChanel API</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepCopy = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; port1, port2 &#125; = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">deepCopy(obj1).then(<span class="function"><span class="params">val</span> =&gt;</span> (obj2 = val));</span><br><span class="line"></span><br><span class="line">obj2.a.b.c = <span class="number">2</span>; <span class="comment">// &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj2); <span class="comment">//  &#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125; &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>这种方法仅在所需拷贝对象含有内置类型并且不包含函数的情况下使用。</p><p>总结:<br>上面三种方式都能实现深拷贝，但都存在问题，目前业界常用的解决方案是使用 lodash 的 cloneDeep api，在下一篇文章尝试阅读该 api 的源码。</p><p>参考</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">MDN - JavaScript 数据类型和数据结构</a><br>《JavaScript 高级程序设计 第 3 版》 第四章<br><a href="https://yuchengkai.cn/docs/frontend/" target="_blank" rel="noopener">InterviewMap</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;深浅拷贝在前端开发中是必然会踩的一个坑，也是面试常考题。至于深浅拷贝为何会存在，主要是跟 JavaScript 的数据类型以及一些历史遗留的问题有关，下面来简单了解下这两者的区别以及如何实现。&lt;/p&gt;
&lt;h1 id=&quot;为何需要深浅拷贝&quot;&gt;&lt;a href=&quot;#为何需要深浅拷贝
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://cirnobreak.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://cirnobreak.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何编写一个简易的模块打包工具</title>
    <link href="https://cirnobreak.github.io/2019/02/26/SimplePacking/"/>
    <id>https://cirnobreak.github.io/2019/02/26/SimplePacking/</id>
    <published>2019-02-25T16:00:00.000Z</published>
    <updated>2020-03-07T14:02:45.334Z</updated>
    
    <content type="html"><![CDATA[<p>在现代前端开发中，像 Webpack、Rollup、Parcel 等打包工具已经成为不可缺少的一部分，其中 Webpack 是最常用的。为了了解 Webpack 的工作原理，再加上自己曾经在面试过程中也被问过如何实现简易的模块打包工具却不知道如何回答，于是打算开始学习这一部分的内容。</p><p>在观看之后，初步了解到 webpack 的打包是先从入口文件开始，以<code>import</code>作为线索去寻找模块，实现一个简易的打包工具也是如此。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在实现简易的打包工具之前，先通过命令来安装我们所需要的模块:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add babylon babel-traverse babel-core</span><br></pre></td></tr></table></figure><p>其中，<code>babylon</code>用于把(入口)文件的代码转换成 AST(抽象语法树),使用<code>babel-travse</code>遍历 AST 的 import 声明(ImportDeclaration)部分来寻找模块依赖关系，把遍历到的内容(模块名)存放到模块依赖数组里面,使用<code>babel-core</code>的<code>transformFromAst</code>模块把(入口)文件的代码(import 不能被浏览器识别)生成的 AST 代码转换成浏览器所能识别的代码(ES6 转 ES5)。</p><p>整个项目的结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-- example</span><br><span class="line">  |-- entry.js</span><br><span class="line">  |-- message.js</span><br><span class="line">  |-- name.js</span><br><span class="line">|-- minipack.js</span><br></pre></td></tr></table></figure><p>其中 example 为我们要打包的的示例，minipack.js 是我们下面要编写的简易的模块打包工具。</p><p>示例的代码如下:</p><p>entry.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">"./message.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure><p>message.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">"./name.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure><p>name.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"hihihhi"</span>;</span><br></pre></td></tr></table></figure><p>准备工作做好了，下面开始编写打包工具的代码。</p><h1 id="第一部分-createAsset-解析依赖关系"><a href="#第一部分-createAsset-解析依赖关系" class="headerlink" title="第一部分 - createAsset(解析依赖关系)"></a>第一部分 - createAsset(解析依赖关系)</h1><p>createAsset 主要用于解析文件内模块依赖信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">"babylon"</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">"babel-traverse"</span>).default;</span><br><span class="line"><span class="keyword">const</span> &#123; transformFromAst &#125; = <span class="built_in">require</span>(<span class="string">"babel-core"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块唯一标识符</span></span><br><span class="line"><span class="keyword">let</span> ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAsset</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以字符串的形式去读取文件的内容</span></span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把文件内容解析为AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = babylon.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">"module"</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块依赖数组(存放模块相对路径)</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历AST里面的import声明</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    ImportDeclartion: <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 把值存放到依赖关系数组里面</span></span><br><span class="line">      dependencies.push(node.source.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配模块唯一标识符，为ID的递增</span></span><br><span class="line">  <span class="keyword">const</span> id = ID++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用`babel-preset-env`的规则转换AST的代码(es6转es5)</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">"env"</span>]</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前文件的所有信息</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id,</span><br><span class="line">    filename,</span><br><span class="line">    dependencies,</span><br><span class="line">    code</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把入口文件代码放到<a href="https://astexplorer.net/" target="_blank" rel="noopener">AST Explorer</a>这个网站上，我们可以很清楚的看到，<code>import message from &#39;./message.js&#39;;</code>这一行代码在<code>ImportDeclaration</code>的部分，是我们遍历的线索，也是使用<code>babel-traverse</code>时的关键。</p><img src="/blog/2019/02/26/SimplePacking/ast.png" class="" title="ast"><p>我们来分析下<code>createAsset</code>做了什么:</p><ol><li>通过传入文件路径，使用<code>fs</code>来读取文件内容。</li><li>通过<code>babylon</code>解析获取到的内容(代码)并解析成<code>AST</code>。</li><li>通过<code>babel-traverse</code>遍历<code>AST</code>，去寻找模块的依赖关系，也就是是否还引入了别的模块，把找到的模块依赖关系存放到<code>dependencies</code>数组。</li><li>使用<code>babel-core</code>的<code>transformFromAst</code>模块，把<code>AST</code>的代码转换成<code>ES5</code>。</li><li>最后返回一个对象，包含当前模块的标识符(id)、当前文件的路径、当前文件的依赖关系以及当前文件转换后的代码。</li></ol><p>最后，运行下代码后输出以下结果:</p><img src="/blog/2019/02/26/SimplePacking/result1.png" class="" title="result1"><h1 id="第二部分-createGraph-生成依赖图"><a href="#第二部分-createGraph-生成依赖图" class="headerlink" title="第二部分 - createGraph(生成依赖图)"></a>第二部分 - createGraph(生成依赖图)</h1><p>这一部分是调用 createAsset 来解析入口文件，从入口文件开始分析模块依赖关系来了解应用程序之间的每一个模块以及他们是如何依赖的，形成<code>依赖图</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry为入口文件的相对路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 解析整个入口文件，获取相关信息</span></span><br><span class="line">  <span class="keyword">const</span> mainAsset = createAsset(entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用队列queue来存放每个asset的依赖关系,初始值是只有mainAsset相关信息的数组</span></span><br><span class="line">  <span class="keyword">const</span> queue = [mainAsset];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历队列</span></span><br><span class="line">  <span class="comment">// 最初队列只有mainAsset，但在遍历过程中，会有新的asset进入队列</span></span><br><span class="line">  <span class="comment">// 循环直队列尾为止</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    <span class="comment">// 存放模块依赖关系</span></span><br><span class="line">    asset.mapping = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取这个模块所在目录的路径</span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历模块依赖关系列表(相对路径)</span></span><br><span class="line">    asset.dependencies.forEach(<span class="function"><span class="params">relativePath</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当前模块所在文件的绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relative);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取当前模块的依赖关系</span></span><br><span class="line">      <span class="keyword">const</span> child = createAsset(absolutePath);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把依赖关系存放到mapping,对应关系为 相对路径 -&gt; 模块id</span></span><br><span class="line">      asset.mapping[relativePath] = child.id;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把child存放到队列</span></span><br><span class="line">      queue.push(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回依赖关系图</span></span><br><span class="line">  <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析下 createGraph 做了什么:</p><ol><li>获取入口文件的信息，然后创建一个数组 queue，先存放入口文件的信息。</li><li>遍历数组，一开始数组只有入口文件的信息，但在遍历的过程中，假如入口文件含有其他依赖的文件，会在遍历过程中<code>push</code>到<code>queue</code>里面，直到文件最后没有依赖，遍历到 queue 队尾时停止遍历。</li><li>在遍历过程中，我们会把依赖关系存放到 mapping 里面，对应关系为: 模块的相对路径 -&gt; 模块 id。</li><li>获取当前模块对应文件的依赖关系，并存放到队列。</li><li>返回队列。</li></ol><p>最后运行代码，结果如下:</p><img src="/blog/2019/02/26/SimplePacking/result2.png" class="" title="result2"><h1 id="最后一部分-bundle"><a href="#最后一部分-bundle" class="headerlink" title="最后一部分 - bundle"></a>最后一部分 - bundle</h1><p>这一部分是把上面 createGraph 生成的信息做整合，打包代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收`createGraph(entry)`生成的信息，打包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历graph的信息，生成传给IIFE的代码</span></span><br><span class="line">  <span class="comment">// 结构: "&#123;0: function (require, module, exports) &#123;xxx&#125;, './xxx': 0&#125;, ..."</span></span><br><span class="line">  graph.forEach(<span class="function"><span class="params">mod</span> =&gt;</span> &#123;</span><br><span class="line">    modules += <span class="string">`<span class="subst">$&#123;mod.id&#125;</span>: [</span></span><br><span class="line"><span class="string">      function (require, module, exports) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;mod.code&#125;</span></span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(mod.mapping)&#125;</span>  </span></span><br><span class="line"><span class="string">    ]`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把commonjs代码转成浏览器能运行的代码</span></span><br><span class="line">  <span class="comment">// require 函数先从0(入口)开始</span></span><br><span class="line">  <span class="comment">// 处理完之后返回result(可以运行的代码)</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">    (function (modules) &#123;</span></span><br><span class="line"><span class="string">      function require (id) &#123;</span></span><br><span class="line"><span class="string">        const [fn, mapping] = modules[id];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        function localRequire(name) &#123;</span></span><br><span class="line"><span class="string">          return require(mapping[name]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        const module = &#123;</span></span><br><span class="line"><span class="string">          exports: &#123;&#125;</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        fn(localRequire, module, module.exports);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return module.exports;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      require(0);</span></span><br><span class="line"><span class="string">    &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><img src="/blog/2019/02/26/SimplePacking/result3.png" class="" title="result3"><p>最后我们把这段代码，拷贝到浏览器控制台，结果如下:</p><img src="/blog/2019/02/26/SimplePacking/result4.png" class="" title="result4"><p>我们发现，他成功的输出了我们想要的结果，大功告成。</p><p>参考</p><blockquote><p><a href="https://www.youtube.com/watch?v=UNMkLHzofQI" target="_blank" rel="noopener">Webpack founder Tobias Koppers demos bundling live by hand</a> &gt; <a href="https://www.youtube.com/watch?v=Gc9-7PBqOC8" target="_blank" rel="noopener">BUILD YOUR OWN WEBPACK by Ronen Amiel</a> &gt; <a href="https://github.com/ronami/minipack" target="_blank" rel="noopener">minipack</a><br>《前端面试之道》 - 实现小型打包工具</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在现代前端开发中，像 Webpack、Rollup、Parcel 等打包工具已经成为不可缺少的一部分，其中 Webpack 是最常用的。为了了解 Webpack 的工作原理，再加上自己曾经在面试过程中也被问过如何实现简易的模块打包工具却不知道如何回答，于是打算开始学习这一部
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://cirnobreak.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://cirnobreak.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>[译]在docker上开发一个简单的React(next.js)应用</title>
    <link href="https://cirnobreak.github.io/2019/01/26/dockernext/"/>
    <id>https://cirnobreak.github.io/2019/01/26/dockernext/</id>
    <published>2019-01-25T16:00:00.000Z</published>
    <updated>2020-03-07T14:02:23.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接: <a href="https://medium.com/@khwsc1/a-simple-react-next-js-app-development-on-docker-6f0bd3f78c2c" target="_blank" rel="noopener">A simple React(Next.js) app development on Docker</a><br>原文作者: <a href="https://medium.com/@khwsc1" target="_blank" rel="noopener">Hyeokwoo Alex Kwon</a></p></blockquote><p>当你要部署一个微服务架构的应用时，在把它部署到生产环境服务器上之前你不能测试它里面所有的服务。通常这会花费很长的时间才能得到反馈。Docker 有助于加快这一过程，因为它使本地小型独立服务更容易链接在一起。</p><p>在这篇文章，我们会通过如何去设置并且使用 docker 来进行 react.js 的应用开发。我们会构建一个简单的 next.js 应用并且把它当做成一个 docker 镜像，以便运行在本机的生产环境上运行一个容器。</p><h1 id="1-构建一个简单的-next-js-应用"><a href="#1-构建一个简单的-next-js-应用" class="headerlink" title="1. 构建一个简单的 next.js 应用"></a>1. 构建一个简单的 next.js 应用</h1><p>首先，我们开始编写一个简单的服务端渲染(ssr)的 react 应用，并通过设置把它做成一个很小的 docker 镜像。我们使用 next.js 库是因为它允许我们去构建一个支持 SSR 的 react 应用。</p><blockquote><p>docker 镜像是一个创建和运行 docker 容器，或者构建其他镜像的文件。docker 镜像包含一个应用和它的执行代码，用于构建和运行。<a href="https://searchitoperations.techtarget.com/definition/Docker-image" target="_blank" rel="noopener">参考</a></p></blockquote><p>让我们用下面的命令在本地新建一个项目:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir docker-nextjs</span><br><span class="line">cd docker-nextjs</span><br><span class="line">yarn init</span><br></pre></td></tr></table></figure><p>在这个刚建的 node.js 项目下安装 next.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add next react react-dom</span><br></pre></td></tr></table></figure><p>我们应该在<code>package.json</code>里面添加 scripts 来更方便地管理应用:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"script": &#123;</span><br><span class="line">  "dev": "next",</span><br><span class="line">  "build": "next build",</span><br><span class="line">  "start": "next start"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来设置最简单的 next.js 路由。首先在主路由上新建一个简单的 hello world 页面。我们可以在项目根目录下新建<code>pages/</code>文件夹，并在里面新建<code>index.js</code>来实现。它会变成一个路由并且在主页面上渲染。</p><p>新建<code>pages/index.js</code>后在编写如下组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index;</span><br></pre></td></tr></table></figure><p>现在我们可以在本地运行<code>yarn dev</code>命令来启动这个应用。你将可以通过<code>localhost:3000</code>来访问应用。</p><h1 id="2-编写-Dockerfile-来构建-docker-镜像"><a href="#2-编写-Dockerfile-来构建-docker-镜像" class="headerlink" title="2. 编写 Dockerfile 来构建 docker 镜像"></a>2. 编写 Dockerfile 来构建 docker 镜像</h1><p>到目前为止，我们已经构建了一个最小的 next.js hellow world 应用，现在我们来让它变成一个 docker 镜像。</p><p>docker 镜像可以在项目里面用单个文件来构建。Dockerfile，在定义上，”Dockerfile 是一个包含所有你通常需要手动执行的,用于构建 docker 镜像的文本文档”。</p><p>因此，主要是通过编写命令来构建和运行应用，您可以构建一个 docker 镜像。当你构建 docker 镜像的时候，docker 系统会读取包含所有命令列表并逐行执行以构建镜像的 Dockerfile。</p><p>好的，下面开始编写 Dockerfile。我们在项目里面新建一个叫<code>Dockerfile</code>的文件，并且在里面编写以下的代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM node:10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作路径。所有的路径都会关联WORKDIR</span></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">COPY package*.json ./</span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝源文件</span></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建应用</span></span><br><span class="line">RUN npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行应用</span></span><br><span class="line">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span><br></pre></td></tr></table></figure><p>这些代码包含用于构建和运行应用的命令集。第一行的<code>FROM node:10</code>,镜像会从 nodejs 官方 docker 镜像获取，因此应用可以在 nodejs 环境中运行。</p><p>下一条命令是用<code>WORKDIR</code>来把应用的工作路径设置成<code>/usr/src/app</code>。因此，当在镜像上运行容器的时候，所有拷贝的和构建好的文件都会在这个地方。</p><p>然后，我们添加<code>npm install</code>命令来安装依赖，并且使用<code>COPY . .</code>命令来拷贝源文件到 docker。我们还应该使用<code>npm run build</code>来把应用打包成生产版本和用<code>npm start</code>来运行应用。</p><p>好的!我们已经准备好用<code>Dockerfile</code>去构建 docker 镜像了。在终端上，定位到你的项目目录，运行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;你的docker用户名&gt;/docker-nextjs</span><br></pre></td></tr></table></figure><p>使用 build 命令，docker 系统会通过<code>Dockerfile</code>上的命令来创建一个新的镜像。<code>-t</code>用于标记你的镜像，使得你更容易地在镜像列表里面找到你的镜像。你可以使用<code>docker image</code>命令来检查 docker 镜像。</p><h1 id="3-在镜像上运行容器"><a href="#3-在镜像上运行容器" class="headerlink" title="3.在镜像上运行容器"></a>3.在镜像上运行容器</h1><p>要使用 docker 实际运行应用，应该基于镜像运行 docker 容器。</p><blockquote><p>容器是 docker 镜像实例化的运行时。到目前为止，我们可以使用构建好的 docker 镜像来创建容器。<a href="https://www.docker.com/resources/what-container" target="_blank" rel="noopener">查看更多</a></p></blockquote><p>由于我们拥有自己的 docker 镜像，我们可以用以下命令创建并且运行 docker 容器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3333:3000 &lt;你的docker用户名&gt;/docker-nextjs:latest</span><br></pre></td></tr></table></figure><p>这行命令会用镜像<code>&lt;你的docker用户名&gt;/docker-nextjs:latest</code>去创建一个容器，并且把端口号绑定到<code>3333:3000</code>。此处的绑定意味着在 docker 里面应用是在<code>3000</code>端口运行，并且可以通过<code>localhost:3000</code>来访问(在本机是<code>localhost:3333</code>)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过阅读这篇文章，你能够掌握用最小最简单的方式来用 docker 部署 react 应用。这个例子只用 docker 部署了简单应用，但但至少您可以使用 docker 更快速地测试生产环境。希望你的生活过得更轻松愉快!🐳</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接: &lt;a href=&quot;https://medium.com/@khwsc1/a-simple-react-next-js-app-development-on-docker-6f0bd3f78c2c&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://cirnobreak.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://cirnobreak.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>从B站弹幕列表加载来了解DOM观察者-MutationObserver</title>
    <link href="https://cirnobreak.github.io/2019/01/20/MutationObserver/"/>
    <id>https://cirnobreak.github.io/2019/01/20/MutationObserver/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2020-03-07T14:02:39.073Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用哔哩哔哩新版播放器的时候感觉十分别扭，侧边有广告，弹幕列表，由于习惯了旧版的默认展开个人不太习惯新版的，就开始打算写一个隐藏侧边广告+默认展开弹幕列表的小脚本，但在编写过程中并不顺利。因为 B 站他们使用的是 SSR 做首屏渲染，首次加载的是骨架屏，服务端渲染的弹幕列表只是一个占位的 div，并没有任何内容，随着后续的客户端渲染才慢慢加载 DOM 元素，但是这到底要怎么做才能去监听它 DOM 变化到渲染出弹幕列表 div 的时候呢？随后我习惯性地使用了 google 去搜索相关的方案，然后找到了一个监听 DOM 树更改的 API - MutationObserver。</p><p>MutationObserver 这个 API 是用来监听 DOM 变动的，DOM 发生的任何变动，比如结点的增减、属性的变动、文本内容的变动都可以从这个 API 上得到通知。它跟事件很接近，但是它跟事件有一个本质的不同点是:事件是同步触发的，即 DOM 变动立马触发相应事件，而 MutationObserver 是异步触发的，DOM 变动不会立马触发，而要等到所有 DOM 操作结束后才触发，这样的设计可以应付 DOM 频繁的变动。</p><p>MutationObserver API 的特点:</p><ol><li>异步触发，等所有 DOM 操作结束后才触发。</li><li>把 DOM 变动记录封装成一个数组处理，而不是一条条个别处理 DOM 变动。</li><li>它可以观察 DOM 的所有类型的变动，也可以指定只观察某一类变动。</li></ol><p>下面用 MDN 文档下 MutationObserver 的示例代码来展示一下这个 API 的实际效果，首先我们尝试监听哔哩哔哩新版播放器的 <code>div.danmaku-wrap</code> ，暂时先移除<code>observer.disconnect()</code>方法，然后在 tampermonkey 下添加脚本，代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="comment">// 被观察的目标节点</span></span><br><span class="line">  <span class="keyword">const</span> targetNode = <span class="built_in">document</span>.querySelector(<span class="string">".danmaku-wrap"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// observer选项</span></span><br><span class="line">  <span class="keyword">const</span> config = &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目标dom发生变动时执行的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">mutationsList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mutation.type == <span class="string">"childList"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"A child node has been added or removed."</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutation.type == <span class="string">"attributes"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">"The "</span> + mutation.attributeName + <span class="string">" attribute was modified."</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化观察者</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始观察</span></span><br><span class="line">  observer.observe(targetNode, config);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>此时，随意在 b 站打开一个视频，并确保播放器切换到新版的情况下，用<code>cmd/ctrl + shift + j</code> 打开控制台，等待<code>div.damaku-wrap</code>渲染后会看到以下输出:</p><img src="/blog/2019/01/20/MutationObserver/danmaku1.png" class="" title="danmaku1"><p>由于以上代码设置了监听元素 style 跟 DOM 树元素增删变化，所以会看到关于两者变化的相关输出动作，这些动作都存放在 mutationList 数组里。</p><p>但是，又到底怎么样才知道弹幕列表里面的内容 div 被渲染呢？</p><p>接下来我们修改下代码，只监听元素节点变动：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="comment">// 被观察的目标节点</span></span><br><span class="line">  <span class="keyword">const</span> targetNode = <span class="built_in">document</span>.querySelector(<span class="string">".danmaku-wrap"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// observer选项</span></span><br><span class="line">  <span class="keyword">const</span> config = &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目标dom发生变动时执行的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">mutationsList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"mutation"</span>, mutation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化观察者</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始观察</span></span><br><span class="line">  observer.observe(targetNode, config);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>继续刷新页面，等待输出。输出结果如下:</p><img src="/blog/2019/01/20/MutationObserver/danmaku2.png" class="" title="danmaku2"><p>此时我们可以看到每次 DOM 结点变动的详细信息，但是我们又该怎么知道到底什么时候才渲染出弹幕列表(-_-)ゞ？</p><p>此时我们使用了<code>Chrome Dev Tools</code> 的 <code>Inspector</code> 找到了弹幕列表 body 的相应元素<code>div.bui-collapse-body</code>。</p><img src="/blog/2019/01/20/MutationObserver/danmaku3.png" class="" title="danmaku3"><p>好了，现在找到了主要目标，但是接下来又该怎么做？</p><p>我们再次修改代码，此时我们主要是看在这个变动列表里面，何时才会渲染出<code>div.player-auxiliary</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="comment">// 被观察的目标节点</span></span><br><span class="line">  <span class="keyword">const</span> targetNode = <span class="built_in">document</span>.querySelector(<span class="string">".danmaku-wrap"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// observer选项</span></span><br><span class="line">  <span class="keyword">const</span> config = &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化观察者</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">mutationsList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"mutation"</span>, mutation);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">".player-auxiliary"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化观察者</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始观察</span></span><br><span class="line">  observer.observe(targetNode, config);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>再次刷新，我们从控制台可以看出来，在第二次 dom 变动的时候渲染出了<code>div.player-auxiliary</code>。</p><img src="/blog/2019/01/20/MutationObserver/danmaku4.png" class="" title="danmaku4"><p>但并不是永远是第二次，在我调试的时候，有视频选集的页面可能并不会是第二次，所以我们继续寻找线索。</p><p>展开第二次输出的信息，我们把<code>player-auxiliary</code>字符串以及它是<code>class</code>作为线索，轻易的找到了它所在的位置：</p><img src="/blog/2019/01/20/MutationObserver/danmaku5.png" class="" title="danmaku5"><p>它就在<code>mutation.target.classList</code>里，此时使用 value 属性做判断条件比较简单，再次修改下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="comment">// 被观察的目标节点</span></span><br><span class="line">  <span class="keyword">const</span> targetNode = <span class="built_in">document</span>.querySelector(<span class="string">".danmaku-wrap"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// observer选项</span></span><br><span class="line">  <span class="keyword">const</span> config = &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Callback function to execute when mutations are observed</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">mutationsList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"mutation"</span>, mutation);</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">"find dom"</span>,</span><br><span class="line">        mutation.target.classList.value.includes(<span class="string">"player-auxiliary"</span>)</span><br><span class="line">      );</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">".player-auxiliary"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化观察者</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始观察</span></span><br><span class="line">  observer.observe(targetNode, config);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>我们再回来看看 console ，发现自从找到它之后，每次都会输出 true。</p><img src="/blog/2019/01/20/MutationObserver/danmaku6.png" class="" title="danmaku6"><p>该如何避免频繁的判断?</p><p>此时借助 flag，当 flag 为 true 后就不再输出 found。来让它找到之后就不再执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="comment">// 被观察的目标节点</span></span><br><span class="line">  <span class="keyword">const</span> targetNode = <span class="built_in">document</span>.querySelector(<span class="string">".danmaku-wrap"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// observer选项</span></span><br><span class="line">  <span class="keyword">const</span> config = &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目标dom发生变动时执行的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">mutationsList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"mutation"</span>, mutation);</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !flag &amp;&amp;</span><br><span class="line">        mutation.target.classList.value.includes(<span class="string">"player-auxiliary"</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">"find dom"</span>,</span><br><span class="line">          mutation.target.classList.value.includes(<span class="string">"player-auxiliary"</span>)</span><br><span class="line">        );</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">".player-auxiliary"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化观察者</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始观察</span></span><br><span class="line">  observer.observe(targetNode, config);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>从输出结果可以看出 found 现在找到之后就不再执行了。</p><img src="/blog/2019/01/20/MutationObserver/danmaku7.png" class="" title="danmaku7"><p>最后，实现弹幕列表自动展开这功能就很简单了，只需要在 if 判断里面执行 弹幕列表 header 的 click 事件即可。代码整理一下，最终的函数如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="comment">// 简单地抽离一下querySelector函数</span></span><br><span class="line">  <span class="keyword">const</span> selector = <span class="function"><span class="params">selector</span> =&gt;</span> <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 被观察的目标节点</span></span><br><span class="line">  <span class="keyword">const</span> targetNode = selector(<span class="string">".danmaku-wrap"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目标dom发生变动时执行的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> config = &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否找到弹幕列表(是否加载出来)</span></span><br><span class="line">  <span class="keyword">const</span> findDom = <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target.classList.value.includes(<span class="string">"player-auxiliary"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化观察者</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">mutationsList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">      <span class="keyword">const</span> target = mutation.target;</span><br><span class="line">      <span class="keyword">if</span> (!flag &amp;&amp; findDom(target)) &#123;</span><br><span class="line">        <span class="comment">// 找到后触发弹幕列表标题点击事件</span></span><br><span class="line">        selector(<span class="string">".bui-collapse-header"</span>).click();</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 停止观察</span></span><br><span class="line">        observer.disconnect();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化观察者</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始观察</span></span><br><span class="line">  observer.observe(targetNode, config);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>参考:</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MDN 文档 MutationObserver API</a> &gt; <a href="http://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="noopener">Javascript 标准参考教程 - Mutation Observer API</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在用哔哩哔哩新版播放器的时候感觉十分别扭，侧边有广告，弹幕列表，由于习惯了旧版的默认展开个人不太习惯新版的，就开始打算写一个隐藏侧边广告+默认展开弹幕列表的小脚本，但在编写过程中并不顺利。因为 B 站他们使用的是 SSR 做首屏渲染，首次加载的是骨架屏，服务端渲染的弹幕
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://cirnobreak.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://cirnobreak.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>windows系统安装Android Studio和配置Flutter</title>
    <link href="https://cirnobreak.github.io/2019/01/10/FlutterWin/"/>
    <id>https://cirnobreak.github.io/2019/01/10/FlutterWin/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2020-03-07T14:02:25.835Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 是谷歌开源的，一个全新的移动 UI 框架，在 2018 年 12 月初发布了 1.0 正式版本，由于本人是做前端开发的，对原生开发不太了解，想从 Flutter 开始入手，但是，在环境配置方面并不是那么的顺利，期间也踩了不少坑。由于环境是 Flutter1.0 发布不久后才部署好的，现在只能考记忆来回顾环境配置的过程。</p><h1 id="需要下载的工具"><a href="#需要下载的工具" class="headerlink" title="需要下载的工具"></a>需要下载的工具</h1><ol><li>Android Studio(需要科学上网): <a href="https://developer.android.com/studio/" target="_blank" rel="noopener">https://developer.android.com/studio/</a></li><li>Flutter SDK 1.0 稳定版 <a href="https://storage.googleapis.com/flutter_infra/releases/stable/windows/flutter_windows_v1.0.0-stable.zip" target="_blank" rel="noopener">https://storage.googleapis.com/flutter_infra/releases/stable/windows/flutter_windows_v1.0.0-stable.zip</a></li></ol><h1 id="设置-Flutter-SDK-环境变量"><a href="#设置-Flutter-SDK-环境变量" class="headerlink" title="设置 Flutter SDK 环境变量"></a>设置 Flutter SDK 环境变量</h1><p>把下载好的<code>Flutter SDK</code>放到任意你觉得方便的位置，解压。然后右键 此电脑，选择属性，依次点击 高级系统设置 -&gt; 环境变量，双击 <code>xxx 的用户变量</code> 下面的<code>path</code>，点新建，然后输入你 Flutter SDK 所在的目录，比如我的 Flutter SDK 是放在 C 盘下的 src，则要输入 C:\src\flutter\bin，其他位置同理，记得一定是定位到<code>bin</code>下面。</p><h1 id="设置-Flutter-SDK-镜像"><a href="#设置-Flutter-SDK-镜像" class="headerlink" title="设置 Flutter SDK 镜像"></a>设置 Flutter SDK 镜像</h1><p>在终端(cmd/powershell)下面输入以下命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"><span class="built_in">set</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><p>即可,详细参考<a href="https://flutter.io/community/china" target="_blank" rel="noopener">https://flutter.io/community/china</a></p><h2 id="运行-Flutter-Doctor"><a href="#运行-Flutter-Doctor" class="headerlink" title="运行 Flutter Doctor"></a>运行 Flutter Doctor</h2><p>打开一个新的 cmd 或 PowerShell，输入 flutter doctor 来运行，flutter doctor 是拿来检测你缺少哪些依赖，一般此时会显示你缺少(虚拟/真实)设备，那此时就需要 Android Studio 的模拟器或者你自己的手机(安卓机)。</p><h1 id="安装-Android-Studio"><a href="#安装-Android-Studio" class="headerlink" title="安装 Android Studio"></a>安装 Android Studio</h1><p>根据提示直接安装到完成，然后打开 Android Studio，如果是第一次安装，可能会提示你缺少 SDK，这是会让你选择下载 SDK 的目录并开始下载(Android SDK 的谷歌镜像速度还是蛮快的，如果觉得慢可以尝试使用国内 Android Studio SDK 镜像),目录尽量不要选择 C 盘(由于 SDK 巨大，之前选择 SDK 装在 C 盘，装了几个之后被占了几十 G)，可以选择你自己喜欢的地方。</p><p>当 SDK 下载完之后，可以进入 Android Studio 的欢迎界面，点击右下角的 configure -&gt; SDK Manager 可以进入 SDK 管理界面。进入界面之后可以看到你 SDK 的安装情况，以及该 SDK 的详情(需要点击右下方的 Show Package Detail)。</p><img src="/blog/2019/01/10/FlutterWin/SDKMAN.png" class="" title="sdkman"><p>假如需要安装新的 SDK，只需要在对应的 SDK 打上勾后点 OK 即可。</p><h2 id="配置-Android-SDK-环境变量"><a href="#配置-Android-SDK-环境变量" class="headerlink" title="配置 Android SDK 环境变量"></a>配置 Android SDK 环境变量</h2><p>在上述的配置环境变量界面，同样是在 <code>xxx 的用户变量</code>下面，点击 <code>新建</code>，新建一个名为<code>ANDROID_HOME</code>的环境变量，然后路径是你 Android SDK 的路径(可通过浏览文件选择)，比如: <code>F:\Android\sdk</code>。</p><img src="/blog/2019/01/10/FlutterWin/asdk.png" class="" title="asdk"><h1 id="新建一个-Flutter-项目"><a href="#新建一个-Flutter-项目" class="headerlink" title="新建一个 Flutter 项目"></a>新建一个 Flutter 项目</h1><h2 id="使用-Android-Studio-创建"><a href="#使用-Android-Studio-创建" class="headerlink" title="使用 Android Studio 创建"></a>使用 Android Studio 创建</h2><p>在 Android Studio 的 欢迎界面 ，也就是一开始的界面，点击 <code>Start a new Flutter project</code>后，进入 <code>Create New Flutter Project</code>的界面后有三个选项，点击第一个<code>Flutter Application</code>后点击 next 此时会让你输入项目名称、项目描述，还有 Flutter SDK 的路径和项目位置的选择，自定义结束后点击 next，后面是包名的配置，定义结束后按 Finish 完成项目创建。</p><h2 id="使用-Visual-Studio-Code-创建"><a href="#使用-Visual-Studio-Code-创建" class="headerlink" title="使用 Visual Studio Code 创建"></a>使用 Visual Studio Code 创建</h2><p>在打开 Visual Studio Code 的情况下，按下组合键 <code>ctrl + shift + x</code>，或者直接点开左边活动栏第四个按钮(拓展)，在应用商店搜索并安装<code>Dart</code>和<code>Flutter</code>插件，插件安装完成后重启 Visual Studio Code。此时在 Visual Studio Code 按下组合键 <code>ctrl + shift + p</code>，输入 Flutter，点击<code>Flutter:New Project</code>，他会让你输入项目名字，比如可以输入 my_app 并按下回车来新建一个叫 my_app 的项目，此时会让你选择该项目的路径，选择完成确定后等待即可。</p><h1 id="运行-Android-Studio-的虚拟机-AVD"><a href="#运行-Android-Studio-的虚拟机-AVD" class="headerlink" title="运行 Android Studio 的虚拟机(AVD)"></a>运行 Android Studio 的虚拟机(AVD)</h1><p>在 Android Studio 打开任意项目，打开后在右上角找到<code>AVD Manager</code>，</p><img src="/blog/2019/01/10/FlutterWin/AVD.png" class="" title="AVD"><p>点击进入，此时可以点击<code>Create Virtual Device</code>来创建虚拟机，根据自己的需求来选择对应型号的虚拟机,选择后点击 next，会进入<code>System Image(系统镜像)</code>选择界面，(由于这里我之前试过被墙，一直转圈无法加载，这种情况出现时需要科学上网),选择对应的安卓系统镜像后(假如没有需要下载)，点 next，编辑好参数后点 finish 即可。<br>虚拟机安装完成之后，<code>AVD Manager</code>里面会成功显示你安装好的虚拟机，此时点击<code>Actions</code>下的绿色按钮即可运行虚拟机。</p><img src="/blog/2019/01/10/FlutterWin/runavd.png" class="" title="runavd"><p>第一次加载需要漫长的加载，请耐心等待。</p><h1 id="运行-Flutter-项目"><a href="#运行-Flutter-项目" class="headerlink" title="运行 Flutter 项目"></a>运行 Flutter 项目</h1><p>Flutter 项目主要运行的是 lib 文件夹下的 main.dart，同时确保真机/模拟器打开。</p><h2 id="Visual-Studio-Code-运行"><a href="#Visual-Studio-Code-运行" class="headerlink" title="Visual Studio Code 运行"></a>Visual Studio Code 运行</h2><p>首先运行虚拟机或者连接真机，然后在 Visual Studio Code 下点开当前项目 lib 文件夹下的 main.dart，按下 F5 即可。</p><h2 id="Android-Studio-运行"><a href="#Android-Studio-运行" class="headerlink" title="Android Studio 运行"></a>Android Studio 运行</h2><p>首先运行虚拟机或者连接真机，然后点击 Android Studio 上方的绿色播放按钮即可。</p><img src="/blog/2019/01/10/FlutterWin/runapp.png" class="" title="runapp">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flutter 是谷歌开源的，一个全新的移动 UI 框架，在 2018 年 12 月初发布了 1.0 正式版本，由于本人是做前端开发的，对原生开发不太了解，想从 Flutter 开始入手，但是，在环境配置方面并不是那么的顺利，期间也踩了不少坑。由于环境是 Flutter1.
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://cirnobreak.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://cirnobreak.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>从Mixins到hooks,浅谈React组件逻辑复用</title>
    <link href="https://cirnobreak.github.io/2018/12/31/%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/"/>
    <id>https://cirnobreak.github.io/2018/12/31/%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2020-03-07T14:02:16.352Z</updated>
    
    <content type="html"><![CDATA[<p>在开发项目的过程中，你可能会发现，在写组件的时候，会出现一种多个组件共用一种逻辑的情况，然而每个组件都重复去实现这同一种逻辑是一件重复性的工作，违背了 DRY(Don’t Repeat Yourself)的原则。那该如何解决这种情况?</p><p>在 Vue.js 中，可以使用 Vue.js 自带的混入(mixins)来解决组件逻辑复用的问题，同样地，React.js 的也自带 Mixins 这种解决方案，但这种方案仅支持 React.createClass 创建组件的形式而不支持 ES6 class 创建的组件(React 官方文档上的说明: <code>ES6 launched without any mixin support. Therefore, there is no support for mixins when you use React with ES6 classes.</code>)。正因如此，后来开始出现了高阶组件 HOC(high order component)、Render Props 以及 react hooks 等解决方案。</p><h1 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h1><p>React 的 mixins 跟 Vue 的 mixins 很相似，都是把公共的逻辑抽离到混入对象里面，然后在组件使用 mixins。下面使用 vue.js 跟 react.js 的 mixins 来实现获取鼠标位置的例子。</p><h2 id="Vue-js-mixins"><a href="#Vue-js-mixins" class="headerlink" title="Vue.js mixins"></a>Vue.js mixins</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">mousemove</span>=<span class="string">"handleMouseMove"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Current mouse position: x : &#123;&#123; x &#125;&#125; y: &#123;&#123; y &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      x: <span class="number">0</span>,</span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  method: &#123;</span><br><span class="line">    handleMouseMove(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = e.clientX;</span><br><span class="line">      <span class="keyword">this</span>.y = e.clientY;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="React-js-Mixins"><a href="#React-js-Mixins" class="headerlink" title="React.js Mixins"></a>React.js Mixins</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">  getInitialState() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      x: <span class="number">0</span>,</span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  handleMouseMove(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x: e.clientX,</span><br><span class="line">      y: e.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = React.createClass(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span> onMouseMove=&#123;<span class="keyword">this</span>.handleMouseMove.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">        Current mouse position: x: &#123;x&#125; y: &#123;y&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, rootElement);</span><br></pre></td></tr></table></figure><h2 id="为何不使用-Mixins"><a href="#为何不使用-Mixins" class="headerlink" title="为何不使用 Mixins?"></a>为何不使用 Mixins?</h2><p>Mixins 看起来十分容易理解，但为什么不推荐使用 Mixins 来复用代码，同时 ES6 class 声明的组件也不支持？</p><p>一、 引入隐式依赖(Mixins introduce implicit dependencies)</p><ol><li><p>JS 是动态语言，很难执行或者记住复杂的依赖的关系。有时候，一个组件会依赖 mixins 里面的特定的方法，比如: <code>getClassName()</code>，有时用另外的方法，在组件上的 mixins 会比如<code>renderHeader()</code>的方法。</p></li><li><p>Mixins 破坏了常见的安全前提，你可以重命名一个状态键或者一个方法，通过在组建中搜索就行。但你可能写一个状态组件，然后你的同事会添加一个读取这个状态(state)的 mixins，几个月后再想修改，把状态提到父组件中便于兄弟间通信的时候，你是否还记得是更新 mixins 而不是去读取一个 prop。</p></li><li><p>隐式依赖对团队新成员继续维护更新一个代码库是非常困难的。</p></li></ol><p>二、 Mixins 造成命名冲突</p><p>不能保证两个单独的 Mixins 可以一起使用。比如 FluxListenerMixin 定义了 handleChange()，WindowSizeMixin 也定义了 handleChange()，你不能一起使用它们，你也不能在自己的组件使用这个名称定义方法。</p><p>三、 Mixins 导致滚雪球式的复杂性</p><p>尽管 Mixins 像上面的例子一样看起来很简单，但是，随着时间推移，它会变得越来越复杂，特别是新需求来了的时候。</p><h1 id="高阶组件-HOC"><a href="#高阶组件-HOC" class="headerlink" title="高阶组件 HOC"></a>高阶组件 HOC</h1><p>在 Mixins 之后，为了更好地实现逻辑复用，在 React 社区里出现了高阶组件这种形式。在 React 官方文档是这样描述的: 高阶组件(HOC)是 react 中对逻辑进行复用的高级技术，并不是 React API。它只是一种模式，这种模式是由 react 自身的组合性质必然产生的(A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React’s compositional nature.)。</p><p>高阶组件本质是一个函数，它接收一个组件作为参数，并返回一个新的组件。比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = highOrderComponent(WrappedComponenet);</span><br></pre></td></tr></table></figure><p>常用的 redux 中的<code>connect</code>方法也是高阶组件的实现。</p><p>下面用高阶组件来实现下 <code>获取当前鼠标位置</code> 的逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withMouseMove = <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">      x: <span class="number">0</span>,</span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    handleMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        x: e.clientX,</span><br><span class="line">        y: e.clientY</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div onMouseMove=&#123;e =&gt; <span class="keyword">this</span>.handleMouseMove(e)&#125;&gt;</span><br><span class="line">          &lt;Component &#123;...this.props&#125; mouse=&#123;<span class="keyword">this</span>.state&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = (&#123; mouse: &#123; x, y &#125; &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    Current mouse position is: x: &#123;x&#125; y: &#123;y&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appWithMouse = withMouseMove(App);</span><br></pre></td></tr></table></figure><p>使用 ES7 装饰器(decorator)实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withMouseMove = <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">      x: <span class="number">0</span>,</span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    handleMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        x: e.clientX,</span><br><span class="line">        y: e.clientY</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div onMouseMove=&#123;e =&gt; <span class="keyword">this</span>.handleMouseMove(e)&#125;&gt;</span><br><span class="line">          &lt;Component &#123;...this.props&#125; mouse=&#123;<span class="keyword">this</span>.state&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">@withMouseMove</span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;</span></span><br><span class="line"><span class="regexp">      mouse: &#123; x, y &#125;</span></span><br><span class="line"><span class="regexp">    &#125; = this.props;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        Current mouse position is: x: &#123;x&#125; y: &#123;y&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶组件高级用法"><a href="#高阶组件高级用法" class="headerlink" title="高阶组件高级用法"></a>高阶组件高级用法</h2><p>一、 一个高阶组件中传入多个组件作为参数。比如实现一个根据是否登录来显示导航栏未登录跟登录的两种状态的组件，分别传入 ComponentForLogin(登录时)和 ComponentForLogout 两个组件作为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withLoginAndLogout = <span class="function">(<span class="params">ComponentForLogin, ComponentForLogout</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> NewComponent = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getUserId()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ComponentForLogin</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ComponentForLogout</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> NewComponent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TopButtons = withLoginAndLogout(LogoutButton, LoginButton);</span><br></pre></td></tr></table></figure><p>二、 高阶组件的链式调用</p><p>假如有三个高阶组件 withOne、withTwo、withThree 来给包装一个高阶组件 X，有几种方式:</p><ol><li>直接包装。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> X1 = withOne(X);</span><br><span class="line"><span class="keyword">const</span> X2 = withTwo(X1);</span><br><span class="line"><span class="keyword">const</span> X3 = withThree(X2);</span><br><span class="line"><span class="keyword">const</span> SuperX = X3; <span class="comment">// 最终的具备三个高阶组件能力的高阶组件SuperX</span></span><br></pre></td></tr></table></figure><p>也可以写成:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SuperX = withThree(withTwo(withOne(x)));</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 compose。</li></ol><p>由于高阶组件本身是一个纯函数，也就是说，可以使用函数式编程里的 compose 来包装 X，即:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hoc = compose(withThree, withTwo, withOne);</span><br><span class="line"><span class="keyword">const</span> SuperX = hoc(X);</span><br></pre></td></tr></table></figure><ol start="3"><li>使用装饰器(decorator)。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@withThree</span><br><span class="line">@withTwo</span><br><span class="line">@withOne</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-displayName-便于调试"><a href="#使用-displayName-便于调试" class="headerlink" title="使用 displayName 便于调试"></a>使用 displayName 便于调试</h2><p>由于高阶组件在<code>React dev tools</code>表现的跟普通组件一样，为了方便调试必须要给一个<code>displayName</code>。最常用的技术就是将包裹组件的名字包装在显示名字中。所以，如果你的高阶组件名字是 <code>withSubscription</code>，且包裹组件的显示名字是 <code>CommentList</code>，那么就是用 <code>WithSubscription(CommentList)</code>这样的<code>displayName</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WithSubscription</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  WithSubscription.displayName = <span class="string">`WithSubscription(<span class="subst">$&#123;getDisplayName(</span></span></span><br><span class="line"><span class="string"><span class="subst">    WrappedComponent</span></span></span><br><span class="line"><span class="string"><span class="subst">  )&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">"Component"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶组件的注意事项"><a href="#高阶组件的注意事项" class="headerlink" title="高阶组件的注意事项"></a>高阶组件的注意事项</h2><ol><li>不要在 render 函数中使用高阶组件。</li></ol><p>React 使用的 diff 算法(Reconciliation，也叫协调)使用组件标识确定是否更新现有的子对象树或丢掉现有的子树并重新挂载。如果 render 函数返回的组件和之前 render 函数返回的组件是相同的，React 就递归地比较新子对象树和旧的子对象树的差异，并更新旧的子对象树。如果它们不相等，就会完全卸载掉旧的子对象树。</p><p>下面的代码会产生问题:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// 每一次render函数调用都会创建一个新的EnhancedComponent实例</span></span><br><span class="line">  <span class="comment">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class="line">  <span class="keyword">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  <span class="comment">// 每一次都会使子对象树完全被卸载或移除</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EnhancedComponent</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里产生的不仅是性能问题，还有重新加载一个组件会引起原有组件所有状态和子组件的丢失。相反，在组件外定义 HOC 使新组建只出现一次的定义，在渲染过程中确保都是同一个组件。</p><ol start="2"><li>必须将静态方法做拷贝</li></ol><p>当使用高阶组件包装组件，原始组件被容器组件包裹，也就意味着新组件会丢失原始组件的所有静态方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义静态方法</span></span><br><span class="line">WrappedComponent.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用高阶组件</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强型组件没有静态方法</span></span><br><span class="line"><span class="keyword">typeof</span> EnhancedComponent.staticMethod === <span class="string">"undefined"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>解决这个问题的方法就是，将原始组件的所有静态方法全部拷贝给新组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhance</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 必须得知道要拷贝的方法</span></span><br><span class="line">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">  <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Ref 属性不能传递(React 16.3 版本提供了一个 <code>React.forwardRef</code> API 解决这个问题)。</li></ol><h1 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h1><p>Render Props 是一种全新的组件复用方式，它指的是，在调用组件时，引入一个函数类型的 prop，这个 prop 定义了组件渲染的方式，换句话说，与其使用 Mixins，或者接收并返回一个组件的高阶组件，还不如在正常使用的情况下添加一个 prop 来实现在消费层面对不同渲染情况的自定义，最终实现代码复用。</p><p>使用 Render Props 来实现<code>获取当前鼠标位置</code>的逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x: e.clientX,</span><br><span class="line">      y: e.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onMouseMove=&#123;e =&gt; <span class="keyword">this</span>.handleMouseMove(e)&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = () =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Mouse</span></span><br><span class="line"><span class="regexp">      render=&#123;(&#123; x, y &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">        &lt;h1&gt;</span></span><br><span class="line"><span class="regexp">          Current mouse position is: x: &#123;x&#125; y: &#123;y&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>h1&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &gt;&lt;<span class="regexp">/Mouse&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="不仅局限于-children-Function-as-Child-Component"><a href="#不仅局限于-children-Function-as-Child-Component" class="headerlink" title="不仅局限于 children(Function as Child Component)"></a>不仅局限于 children(Function as Child Component)</h2><p>Function as Child Component 是指父组件接收一个函数来实现复用。这种方式 C 的特点在于父组件往往拥有一些内部状态或者需要做一些复杂且共享的计算，这些数据需要对外暴露来实现复用。</p><p>使用 Fuction as Child Component 来实现<code>获取当前鼠标位置</code>的逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x: e.clientX,</span><br><span class="line">      y: e.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onMouseMove=&#123;e =&gt; <span class="keyword">this</span>.handleMouseMove(e)&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = () =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Mouse&gt;</span></span><br><span class="line"><span class="regexp">      &#123;(&#123; x, y &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          Current mouse position is: x: &#123;x&#125; y: &#123;y&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/Mouse&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><p>Hooks 是 React v16.7.0-alpha 引入的概念(截止 2018.12.31 React 的正式版为 16.7，暂时没有 Hooks)，以后正式发布 API 可能会变化。Hooks 的主要目的是让开发者摆脱 class 来实现组件。其中 useState 是实现在不编写 class 的情况下使用 state 的方法，而 useEffect 是在不编写 class 的情况下来替代 React 生命周期的一些副作用的方法。</p><p>使用简单的 Hooks 来实现<code>获取鼠标位置</code>的逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePos</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [pos, setPos] = useState(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handlePos</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    setPos(&#123; <span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    element.current.addEventListener(<span class="string">"mousemove"</span>, handlePos);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      element.current.removeEventListener(<span class="string">"mousemove"</span>, handlePos);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ele = React.createRef();</span><br><span class="line">  <span class="keyword">const</span> pos = usePos(textInput);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div ref=&#123;ele&#125;&gt;</span><br><span class="line">      Current mouse position is: x: &#123;pos.x&#125; <span class="number">7</span>: &#123;pos.y&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>参考</p><blockquote><p>React.js 官方文档<br><a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a><br>掘金小册《React 实战：设计模式和最佳实践》<br>《React 状态管理与同构实战》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发项目的过程中，你可能会发现，在写组件的时候，会出现一种多个组件共用一种逻辑的情况，然而每个组件都重复去实现这同一种逻辑是一件重复性的工作，违背了 DRY(Don’t Repeat Yourself)的原则。那该如何解决这种情况?&lt;/p&gt;
&lt;p&gt;在 Vue.js 中，可
      
    
    </summary>
    
    
      <category term="React" scheme="https://cirnobreak.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://cirnobreak.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>vim学习之vimtutor笔记</title>
    <link href="https://cirnobreak.github.io/2018/11/27/vim%E5%AD%A6%E4%B9%A0%E4%B9%8Bvimtutor%E7%AC%94%E8%AE%B0/"/>
    <id>https://cirnobreak.github.io/2018/11/27/vim%E5%AD%A6%E4%B9%A0%E4%B9%8Bvimtutor%E7%AC%94%E8%AE%B0/</id>
    <published>2018-11-26T16:00:00.000Z</published>
    <updated>2020-03-07T14:02:48.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h1><p>h(左移) j(下移) k(右移) l(右移)，也可以使用方向键。</p><h1 id="进入跟退出"><a href="#进入跟退出" class="headerlink" title="进入跟退出"></a>进入跟退出</h1><p>进入: 输入 vim 文件名 &lt;回车&gt;。</p><p>退出:</p><ol><li>保存并退出:输入 :wq! &lt;回车&gt;。</li><li>退出但不保存: 输入 :q! &lt;回车&gt;。</li></ol><h1 id="删除单个字符"><a href="#删除单个字符" class="headerlink" title="删除单个字符"></a>删除单个字符</h1><p>在正常模式下在光标所在位置按 x 可以删除光标所在位置单个字符。</p><h1 id="插入-添加"><a href="#插入-添加" class="headerlink" title="插入/添加"></a>插入/添加</h1><ol><li>光标前插入: 输入 i。</li><li>当前行最后插入: 输入 A。</li><li>在当前光标后插入: 输入 a。</li></ol><h1 id="计数指定动作"><a href="#计数指定动作" class="headerlink" title="计数指定动作"></a>计数指定动作</h1><p>比如:</p><ol><li>输入 2w 光标往后移动两个单词。</li><li>输入 3e 光标往后移动到第三个单词的词尾。</li><li>输入 0 移动光标到行首。</li></ol><h1 id="删除相关命令-与-d-有关"><a href="#删除相关命令-与-d-有关" class="headerlink" title="删除相关命令(与 d 有关)"></a>删除相关命令(与 d 有关)</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>许多改变文本的命令都由一个操作符和一个动作构成。使用删除操作符 d 的删除命令的格式如下:</p><p>d motion</p><p>其中 d 是删除操作符，motion 是操作符的操作对象,比如:</p><ol><li>删除从当前光标到下一个单词的起始处: 输入 dw。</li><li>删除光标到单词末尾，包括最后一个字符: 输入 de。</li><li>删除从当前光标到行末的所有字符: 输入 d$。</li></ol><h2 id="计数删除"><a href="#计数删除" class="headerlink" title="计数删除"></a>计数删除</h2><p>在删除操作符跟动作的组合中，在动作前加上一个数字可以删除更多:</p><p>d number(数字) motion</p><p>比如输入 d2w 可以删除两个单词。</p><h2 id="删除整行"><a href="#删除整行" class="headerlink" title="删除整行"></a>删除整行</h2><ol><li>输入 dd 可以删除当前行。</li><li>输入 2dd 可以删除两行。</li></ol><h1 id="撤销类命令"><a href="#撤销类命令" class="headerlink" title="撤销类命令"></a>撤销类命令</h1><ol><li>按下 u 可以恢复上一次操作。</li><li>按下 U 可以恢复光标所在行的初始状态。</li><li>按 CTRL+R 可以重做被撤销的命令，也就是撤销掉撤销命令。</li></ol><h1 id="置入类命令"><a href="#置入类命令" class="headerlink" title="置入类命令"></a>置入类命令</h1><p>p 可以把最后一次删除(复制)的内容置入光标之后。</p><p>比如： 把一行移动到指定位置，可以先用 dd 命令删除该行，这样会将该行保存到 vim 的寄存器中，然后在光标所在行按下 p，会在光标后所在行的下一行粘贴置入。</p><h1 id="替换类命令"><a href="#替换类命令" class="headerlink" title="替换类命令"></a>替换类命令</h1><ol><li>在光标所在位置输入 r 和要替换的字符，就会把当前光标的内容替换成你要替换的内容。</li><li>在光标所在位置输入 R 可以连续替换字符。</li></ol><h1 id="更改类命令"><a href="#更改类命令" class="headerlink" title="更改类命令"></a>更改类命令</h1><p>在光标所在位置，输入 cw 不仅可以删掉一个单词，同时可以进入插入模式。</p><p>更改类操作命令如下:</p><p>c [number] motion</p><h1 id="定位以及文件状态"><a href="#定位以及文件状态" class="headerlink" title="定位以及文件状态"></a>定位以及文件状态</h1><ol><li>按下 CTRL+G 可以显示光标所在行的位置以及文件状态信息。</li><li>输入 G 可以跳到文件的最后一行，输入 gg 可以跳到文件的第一行。</li></ol><h1 id="搜索类命令"><a href="#搜索类命令" class="headerlink" title="搜索类命令"></a>搜索类命令</h1><ol><li>输入 / 跟 要查找的字符串并按下 &lt;回车&gt;，比如: /errroor &lt;回车&gt;，可以在文件中找到你要找的字符串的位置。</li><li>此时按 n 可以往下查找，按下 N 可以往上查找。</li><li>如果是第一次逆向查找，使用? 代替 /即可。</li><li>ctrl+o 可以回退到之前查找的位置，ctrl+i 可以跳到较新位置。</li></ol><h1 id="配对括号查找"><a href="#配对括号查找" class="headerlink" title="配对括号查找"></a>配对括号查找</h1><p>%可以跳转到匹配当前行离光标最近的括号({[或者)}] 对应匹配的)}]或者({[的位置。</p><h1 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h1><ol><li>在光标所在行，把头一个 old 替换成 new，输入 :s/old/new。</li><li>在光标所在行，把所有 old 替换成 new，输入 :s/old/new/g。</li><li>在光标所在处的两行内把所有的 old 替换成 new，输入 :#,#/old/new/g。</li><li>把文件内所有的 old 替换成 new，输入 :%s/old/new/gc。</li></ol><h1 id="执行外部命令"><a href="#执行外部命令" class="headerlink" title="执行外部命令"></a>执行外部命令</h1><p>输入:!紧跟着外部命令就会执行该外部命令，比如:</p><p>输入 :!ls 可以列举目录内容。</p><h1 id="保存改动到文件"><a href="#保存改动到文件" class="headerlink" title="保存改动到文件"></a>保存改动到文件</h1><p>输入 :w 文件名就可以把当前文件另存为该文件名的文件。</p><p>此时，如果想删除文件，可以使用如下命令:</p><ol><li>MS-DOC 下，输入 :!del 文件名。</li><li>Unix 下，输入 :!rm 文件名。</li></ol><h1 id="保存指定文本到文件"><a href="#保存指定文本到文件" class="headerlink" title="保存指定文本到文件"></a>保存指定文本到文件</h1><p>按下 v 可以进入视图模式，然后移动光标选中文本会高亮，此时，输入 : 屏幕底部会出现:’&lt;,’&gt; 接着输入 w 文件名 会看到 :’&lt;,’&gt;w 文件名 ,按下&lt;回车&gt;后，将会把选中的文本保存当对应的文件下。</p><h1 id="提取并合并文件"><a href="#提取并合并文件" class="headerlink" title="提取并合并文件"></a>提取并合并文件</h1><p>当光标所在位置，输入 :r 文件名 会把对应文件名的内容提取到当前位置并置入。</p><h1 id="打开类命令"><a href="#打开类命令" class="headerlink" title="打开类命令"></a>打开类命令</h1><p>在光标处，输入 o 会在光标下方新建一行并进入插入模式，输入 O 则会往光标上方新建一行并进入插入模式。</p><h1 id="复制粘贴文本"><a href="#复制粘贴文本" class="headerlink" title="复制粘贴文本"></a>复制粘贴文本</h1><p>输入 y 可以复制对应文本，输入 p 可以把复制的文本粘贴到光标后的位置。</p><h1 id="设置类命令"><a href="#设置类命令" class="headerlink" title="设置类命令"></a>设置类命令</h1><p>输入 :set xxx 可以设置 xxx 选项。</p><ol><li>输入 :set ic,表示查找时忽略字母大小写(ignorecase)</li><li>输入 :set is,表示查找短语时显示部分匹配(incsearch)</li><li>输入 :set hls,表示高亮显示所有匹配短语(hlsearch)</li><li>在选项前输入 no 可以关闭选项，比如 :set noic 可以取消忽略大小写查找</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方向&quot;&gt;&lt;a href=&quot;#方向&quot; class=&quot;headerlink&quot; title=&quot;方向&quot;&gt;&lt;/a&gt;方向&lt;/h1&gt;&lt;p&gt;h(左移) j(下移) k(右移) l(右移)，也可以使用方向键。&lt;/p&gt;
&lt;h1 id=&quot;进入跟退出&quot;&gt;&lt;a href=&quot;#进入跟退出&quot; 
      
    
    </summary>
    
    
      <category term="vim" scheme="https://cirnobreak.github.io/categories/vim/"/>
    
    
      <category term="笔记" scheme="https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="vim" scheme="https://cirnobreak.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Vue同时使用@keyup.enter与@blur冲突</title>
    <link href="https://cirnobreak.github.io/2018/08/30/vue%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8@keyup.enter%E4%B8%8E@blur%E5%86%B2%E7%AA%81/"/>
    <id>https://cirnobreak.github.io/2018/08/30/vue%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8@keyup.enter%E4%B8%8E@blur%E5%86%B2%E7%AA%81/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2020-03-07T14:02:50.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-同时使用-keyup-enter-与-blur-冲突"><a href="#vue-同时使用-keyup-enter-与-blur-冲突" class="headerlink" title="vue 同时使用@keyup.enter 与@blur 冲突"></a>vue 同时使用@keyup.enter 与@blur 冲突</h1><p>参考</p><blockquote><p><a href="https://www.jianshu.com/p/1d94bb8be9c3" target="_blank" rel="noopener">https://www.jianshu.com/p/1d94bb8be9c3</a></p></blockquote><p>最近在项目开发过程中，要实现一个可编辑标签。在提交修改的时候，需要做到按回车跟失去焦点都可以触发提交请求的操作，但是，在同一个标签上写@keyup.enter 与@blur 的时候，分别写单独的事件，会发现，按下回车的时候，不仅触发了@keyup.enter 的事件，还触发了@blur 的事件。</p><p>未修改前(冲突)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"editTag"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:id</span>=<span class="string">"tag.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:data-id</span>=<span class="string">"tag.foodId+'-'+tag.orderNo"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-if</span>=<span class="string">"editable"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">"preventSwitch"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.enter</span>=<span class="string">"editTagName($event, tag.name)"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">slot</span>=<span class="string">"label"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">"editTagName($event, tag.name)"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">contenteditable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  &#123;&#123;tag.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后，回车时直接调用了 blur，避免冲突</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"editTag"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:id</span>=<span class="string">"tag.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:data-id</span>=<span class="string">"tag.foodId+'-'+tag.orderNo"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-if</span>=<span class="string">"editable"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">"preventSwitch"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.enter</span>=<span class="string">"$event.target.blur"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">slot</span>=<span class="string">"label"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">"editTagName($event, tag.name)"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">contenteditable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  &#123;&#123;tag.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue-同时使用-keyup-enter-与-blur-冲突&quot;&gt;&lt;a href=&quot;#vue-同时使用-keyup-enter-与-blur-冲突&quot; class=&quot;headerlink&quot; title=&quot;vue 同时使用@keyup.enter 与@blur 冲突&quot;&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://cirnobreak.github.io/categories/JavaScript/"/>
    
    
      <category term="Vue" scheme="https://cirnobreak.github.io/tags/Vue/"/>
    
      <category term="踩坑" scheme="https://cirnobreak.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
</feed>
