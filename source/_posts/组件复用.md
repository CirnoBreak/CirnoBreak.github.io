---
title: 从Mixins到hooks,浅谈React组件逻辑复用
tags: [React]
archives_title: Archives
categories: React
date: 2018-12-31
---

在开发项目的过程中，你可能会发现，在写组件的时候，会出现一种多个组件共用一种逻辑的情况，然而每个组件都重复去实现这同一种逻辑是一件重复性的工作，违背了 DRY(Don't Repeat Yourself)的原则。那该如何解决这种情况?

在 Vue.js 中，可以使用 Vue.js 自带的混入(mixins)来解决组件逻辑复用的问题，同样地，React.js 的也自带 Mixins 这种解决方案，但这种方案仅支持 React.createClass 创建组件的形式而不支持 ES6 class 创建的组件(React 官方文档上的说明: `ES6 launched without any mixin support. Therefore, there is no support for mixins when you use React with ES6 classes.`)。正因如此，后来开始出现了高阶组件 HOC(high order component)、Render Props 以及 react hooks 等解决方案。

# Mixins

React 的 mixins 跟 Vue 的 mixins 很相似，都是把公共的逻辑抽离到混入对象里面，然后在组件使用 mixins。下面使用 vue.js 跟 react.js 的 mixins 来实现获取鼠标位置的例子。

## Vue.js mixins

```html
<template>
  <div @mousemove="handleMouseMove">
    <h1>Current mouse position: x : {{ x }} y: {{ y }}</h1>
  </div>
</template>
```

```js
const mixin = {
  data() {
    return {
      x: 0,
      y: 0
    };
  },
  method: {
    handleMouseMove(e) {
      this.x = e.clientX;
      this.y = e.clientY;
    }
  }
};

new Vue({
  mixins: [mixin]
});
```

## React.js Mixins

```js
const mixin = {
  getInitialState() {
    return {
      x: 0,
      y: 0
    };
  },
  handleMouseMove(e) {
    this.setState({
      x: e.clientX,
      y: e.clientY
    });
  }
};

const App = React.createClass({
  mixins: [mixin],
  render() {
    const { x, y } = this.state;
    return (
      <div className="App" onMouseMove={this.handleMouseMove.bind(this)}>
        Current mouse position: x: {x} y: {y}
      </div>
    );
  }
});

const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement);
```

## 为何不使用 Mixins?

Mixins 看起来十分容易理解，但为什么不推荐使用 Mixins 来复用代码，同时 ES6 class 声明的组件也不支持？

一、 引入隐式依赖(Mixins introduce implicit dependencies)

1. JS 是动态语言，很难执行或者记住复杂的依赖的关系。有时候，一个组件会依赖 mixins 里面的特定的方法，比如: `getClassName()`，有时用另外的方法，在组件上的 mixins 会比如`renderHeader()`的方法。

2. Mixins 破坏了常见的安全前提，你可以重命名一个状态键或者一个方法，通过在组建中搜索就行。但你可能写一个状态组件，然后你的同事会添加一个读取这个状态(state)的 mixins，几个月后再想修改，把状态提到父组件中便于兄弟间通信的时候，你是否还记得是更新 mixins 而不是去读取一个 prop。

3. 隐式依赖对团队新成员继续维护更新一个代码库是非常困难的。

二、 Mixins 造成命名冲突

不能保证两个单独的 Mixins 可以一起使用。比如 FluxListenerMixin 定义了 handleChange()，WindowSizeMixin 也定义了 handleChange()，你不能一起使用它们，你也不能在自己的组件使用这个名称定义方法。

三、 Mixins 导致滚雪球式的复杂性

尽管 Mixins 像上面的例子一样看起来很简单，但是，随着时间推移，它会变得越来越复杂，特别是新需求来了的时候。

# 高阶组件 HOC

在 Mixins 之后，为了更好地实现逻辑复用，在 React 社区里出现了高阶组件这种形式。在 React 官方文档是这样描述的: 高阶组件(HOC)是 react 中对逻辑进行复用的高级技术，并不是 React API。它只是一种模式，这种模式是由 react 自身的组合性质必然产生的(A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React’s compositional nature.)。

高阶组件本质是一个函数，它接收一个组件作为参数，并返回一个新的组件。比如:

```js
const EnhancedComponent = highOrderComponent(WrappedComponenet);
```

常用的 redux 中的`connect`方法也是高阶组件的实现。

下面用高阶组件来实现下 `获取当前鼠标位置` 的逻辑:

```js
const withMouseMove = Component => {
  return class extends Component {
    state = {
      x: 0,
      y: 0
    };

    handleMouseMove = e => {
      this.setState({
        x: e.clientX,
        y: e.clientY
      });
    };

    render() {
      return (
        <div onMouseMove={e => this.handleMouseMove(e)}>
          <Component {...this.props} mouse={this.state} />
        </div>
      );
    }
  };
};

const App = ({ mouse: { x, y } }) => (
  <div>
    Current mouse position is: x: {x} y: {y}
  </div>
);

const appWithMouse = withMouseMove(App);
```

使用 ES7 装饰器(decorator)实现:

```js
const withMouseMove = Component => {
  return class extends React.Component {
    state = {
      x: 0,
      y: 0
    };

    handleMouseMove = e => {
      this.setState({
        x: e.clientX,
        y: e.clientY
      });
    };

    render() {
      return (
        <div onMouseMove={e => this.handleMouseMove(e)}>
          <Component {...this.props} mouse={this.state} />
        </div>
      );
    }
  };
};
@withMouseMove
class App extends React.Component {
  render() {
    const {
      mouse: { x, y }
    } = this.props;

    return (
      <div>
        Current mouse position is: x: {x} y: {y}
      </div>
    );
  }
}
```

## 高阶组件高级用法

一、 一个高阶组件中传入多个组件作为参数。比如实现一个根据是否登录来显示导航栏未登录跟登录的两种状态的组件，分别传入 ComponentForLogin(登录时)和 ComponentForLogout 两个组件作为参数。

```js
const withLoginAndLogout = (ComponentForLogin, ComponentForLogout) => {
  const NewComponent = props => {
    if (getUserId()) {
      return <ComponentForLogin {...props} />;
    } else {
      return <ComponentForLogout {...props} />;
    }
  };
  return NewComponent;
};

const TopButtons = withLoginAndLogout(LogoutButton, LoginButton);
```

二、 高阶组件的链式调用

假如有三个高阶组件 withOne、withTwo、withThree 来给包装一个高阶组件 X，有几种方式:

1. 直接包装。

```js
const X1 = withOne(X);
const X2 = withTwo(X1);
const X3 = withThree(X2);
const SuperX = X3; // 最终的具备三个高阶组件能力的高阶组件SuperX
```

也可以写成:

```js
const SuperX = withThree(withTwo(withOne(x)));
```

2. 使用 compose。

由于高阶组件本身是一个纯函数，也就是说，可以使用函数式编程里的 compose 来包装 X，即:

```js
function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg;
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}

const hoc = compose(withThree, withTwo, withOne);
const SuperX = hoc(X);
```

3. 使用装饰器(decorator)。

```js
@withThree
@withTwo
@withOne
class X extends React.Component {
  /*...*/
}
```

## 使用 displayName 便于调试

由于高阶组件在`React dev tools`表现的跟普通组件一样，为了方便调试必须要给一个`displayName`。最常用的技术就是将包裹组件的名字包装在显示名字中。所以，如果你的高阶组件名字是 `withSubscription`，且包裹组件的显示名字是 `CommentList`，那么就是用 `WithSubscription(CommentList)`这样的`displayName`:

```js
function withSubscription(WrappedComponent) {
  class WithSubscription extends React.Component {
    /* ... */
  }
  WithSubscription.displayName = `WithSubscription(${getDisplayName(
    WrappedComponent
  )})`;
  return WithSubscription;
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || "Component";
}
```

## 高阶组件的注意事项

1. 不要在 render 函数中使用高阶组件。

React 使用的 diff 算法(Reconciliation，也叫协调)使用组件标识确定是否更新现有的子对象树或丢掉现有的子树并重新挂载。如果 render 函数返回的组件和之前 render 函数返回的组件是相同的，React 就递归地比较新子对象树和旧的子对象树的差异，并更新旧的子对象树。如果它们不相等，就会完全卸载掉旧的子对象树。

下面的代码会产生问题:

```js
render() {
  // 每一次render函数调用都会创建一个新的EnhancedComponent实例
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 每一次都会使子对象树完全被卸载或移除
  return <EnhancedComponent />;
}
```

在这里产生的不仅是性能问题，还有重新加载一个组件会引起原有组件所有状态和子组件的丢失。相反，在组件外定义 HOC 使新组建只出现一次的定义，在渲染过程中确保都是同一个组件。

2. 必须将静态方法做拷贝

当使用高阶组件包装组件，原始组件被容器组件包裹，也就意味着新组件会丢失原始组件的所有静态方法。

```js
// 定义静态方法
WrappedComponent.staticMethod = function() {
  /*...*/
};
// 使用高阶组件
const EnhancedComponent = enhance(WrappedComponent);

// 增强型组件没有静态方法
typeof EnhancedComponent.staticMethod === "undefined"; // true
```

解决这个问题的方法就是，将原始组件的所有静态方法全部拷贝给新组件:

```js
function enhance(WrappedComponent) {
  class Enhance extends React.Component {
    /*...*/
  }
  // 必须得知道要拷贝的方法
  Enhance.staticMethod = WrappedComponent.staticMethod;
  return Enhance;
}
```

3. Ref 属性不能传递(React 16.3 版本提供了一个 `React.forwardRef` API 解决这个问题)。

# Render Props

Render Props 是一种全新的组件复用方式，它指的是，在调用组件时，引入一个函数类型的 prop，这个 prop 定义了组件渲染的方式，换句话说，与其使用 Mixins，或者接收并返回一个组件的高阶组件，还不如在正常使用的情况下添加一个 prop 来实现在消费层面对不同渲染情况的自定义，最终实现代码复用。

使用 Render Props 来实现`获取当前鼠标位置`的逻辑:

```js
class Mouse extends React.Component {
  state = {
    x: 0,
    y: 0
  };

  handleMouseMove = e => {
    this.setState({
      x: e.clientX,
      y: e.clientY
    });
  };

  render() {
    return (
      <div onMouseMove={e => this.handleMouseMove(e)}>
        {this.props.render(this.state)}
      </div>
    );
  }
}

const App = () => (
  <div>
    <Mouse
      render={({ x, y }) => (
        <h1>
          Current mouse position is: x: {x} y: {y}
        </h1>
      )}
    ></Mouse>
  </div>
);
```

## 不仅局限于 children(Function as Child Component)

Function as Child Component 是指父组件接收一个函数来实现复用。这种方式 C 的特点在于父组件往往拥有一些内部状态或者需要做一些复杂且共享的计算，这些数据需要对外暴露来实现复用。

使用 Fuction as Child Component 来实现`获取当前鼠标位置`的逻辑:

```js
class Mouse extends React.Component {
  state = {
    x: 0,
    y: 0
  };

  handleMouseMove = e => {
    this.setState({
      x: e.clientX,
      y: e.clientY
    });
  };

  render() {
    return (
      <div onMouseMove={e => this.handleMouseMove(e)}>
        {this.props.children(this.state)}
      </div>
    );
  }
}

const App = () => (
  <div>
    <Mouse>
      {({ x, y }) => (
        <div>
          Current mouse position is: x: {x} y: {y}
        </div>
      )}
    </Mouse>
  </div>
);
```

# Hooks

Hooks 是 React v16.7.0-alpha 引入的概念(截止 2018.12.31 React 的正式版为 16.7，暂时没有 Hooks)，以后正式发布 API 可能会变化。Hooks 的主要目的是让开发者摆脱 class 来实现组件。其中 useState 是实现在不编写 class 的情况下使用 state 的方法，而 useEffect 是在不编写 class 的情况下来替代 React 生命周期的一些副作用的方法。

使用简单的 Hooks 来实现`获取鼠标位置`的逻辑:

```js
function usePos(element) {
  let [pos, setPos] = useState({ x: 0, y: 0 });

  function handlePos(e) {
    setPos({ x: e.clientX, y: e.clientY });
  }

  useEffect(() => {
    element.current.addEventListener("mousemove", handlePos);
    return () => {
      element.current.removeEventListener("mousemove", handlePos);
    };
  }, []);

  return pos;
}

function App() {
  let ele = React.createRef();
  const pos = usePos(textInput);
  return (
    <div ref={ele}>
      Current mouse position is: x: {pos.x} 7: {pos.y}}
    </div>
  );
}
```

参考

> React.js 官方文档
> [Mixins Considered Harmful](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)
> 掘金小册《React 实战：设计模式和最佳实践》
> 《React 状态管理与同构实战》
