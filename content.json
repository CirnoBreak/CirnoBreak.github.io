{"meta":{"title":"Welcome to my blog!","subtitle":null,"description":null,"author":null,"url":"https://cirnobreak.github.io","root":"/blog/"},"pages":[{"title":"tags","date":"2018-03-20T08:45:49.000Z","updated":"2019-01-22T10:44:47.644Z","comments":false,"path":"tags/index.html","permalink":"https://cirnobreak.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-20T09:00:08.000Z","updated":"2019-01-22T10:44:47.642Z","comments":false,"path":"categories/index.html","permalink":"https://cirnobreak.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode day11 - 将数组分成和相等的三个部分","slug":"leetcodeday11","date":"2020-03-10T16:00:00.000Z","updated":"2020-03-11T11:34:29.661Z","comments":true,"path":"2020/03/11/leetcodeday11/","link":"","permalink":"https://cirnobreak.github.io/2020/03/11/leetcodeday11/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/ 题目描述给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。 形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。 示例 1： 123输出：[0,2,1,-6,6,-7,9,1,2,0,1]输出：true解释：0 + 2 + 1 &#x3D; -6 + 6 - 7 + 9 + 1 &#x3D; 2 + 0 + 1 示例 2： 12输入：[0,2,1,-6,6,7,9,-1,2,0,1]输出：false 示例 3： 123输入：[3,3,6,5,-2,2,5,1,-9,4]输出：true解释：3 + 3 &#x3D; 6 &#x3D; 5 - 2 + 2 + 5 + 1 - 9 + 4 解题思路遍历法由题意可知，要分成和相等的三部分，首先需要需要计算出整个的数组元素之和 sum，除以三得到每一部分的元素之和。有一种特殊情况是，数组之和为 0，可以分成大于或者等于和相等的部分。我们可以用声明一个变量 equalCount 来记录和相等的分组数，用于判断是否符合条件，tmp 用于记录临时的数组部分之和，用于判断是否符合等分条件。因此只需要在遍历的时候，判断当前部分累加之和是否等于 sum / 3，符合就给 equalCount + 1，直到最后，判断 equalCount 是否大于或者等于 3 即可（大于 3 的情况是数组之和 sum 为 0 的情况）。 代码： 123456789101112131415161718192021222324/** * @param &#123;number[]&#125; A * @return &#123;boolean&#125; */var canThreePartsEqualSum = function(A) &#123; // 数组元素之和 let sum = 0; for (let i = 0; i &lt; A.length; i++) &#123; sum += A[i]; &#125; // 数组部分和 tmp， 目标 target，符合条件的分组数 equalCount let tmp = 0, target = sum / 3, equalCount = 0; for (let j = 0; j &lt; A.length; j++) &#123; tmp += A[j]; // 如果符合条件，equalCount + 1，并清空数组的部分和tmp if (tmp === target) &#123; tmp = 0; equalCount++; &#125; &#125; return equalCount &gt;= 3;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day10 - 二叉树的直径","slug":"leetcodeday10","date":"2020-03-09T16:00:00.000Z","updated":"2020-03-10T10:04:02.256Z","comments":true,"path":"2020/03/10/leetcodeday10/","link":"","permalink":"https://cirnobreak.github.io/2020/03/10/leetcodeday10/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/diameter-of-binary-tree/ 题目描述给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 :给定二叉树 12345 1 &#x2F; \\ 2 3 &#x2F; \\4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 解题思路深度优先搜索(DFS)本题的核心就是寻找二叉树左子树的最大深度和右子树的最大深度之和加上根节点(1)，可以拆分为不断遍历左右子树，通过回溯（自底向上）累加（空的时候为 0， 存在的时候加 1）得到当前节点的左右子树深度，并取最大值，可以参考link的 ppt。 代码： 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var diameterOfBinaryTree = function(root) &#123; // 路径长度初始值 let ans = 0; function depth(node) &#123; // 没有左/右子树时返回0 if (!node) &#123; return 0; &#125; // 遍历左子树 const leftChildNum = depth(node.left); // 遍历右子树 const rightChildNum = depth(node.right); // 取路径最大值赋值给ans ans = Math.max(ans, leftChildNum + rightChildNum); // 取当前节点的左右子树中最长的路径，往上一步(+1) return Math.max(leftChildNum, rightChildNum) + 1; &#125; depth(root); return ans;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day09 - 买卖股票的最佳时机","slug":"leetcodeday09","date":"2020-03-08T16:00:00.000Z","updated":"2020-03-09T14:28:27.499Z","comments":true,"path":"2020/03/09/leetcodeday09/","link":"","permalink":"https://cirnobreak.github.io/2020/03/09/leetcodeday09/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。 注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路暴力枚举暴力枚举比较简单，就是一直与之前的天数做减法运算，与临时变量 max 做对比，存放更大的值。 代码： 12345678910111213141516171819/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; // 存放最大值的临时变量 let max = 0; for (let i = 0; i &lt; prices.length; i++) &#123; for (let j = i; j &lt; prices.length; j++) &#123; // 求差值 const delta = prices[j] - prices[i]; // 判断是否为当前最大值 if (delta &gt; max) &#123; max = delta; &#125; &#125; &#125; return max;&#125;; 一次遍历只需通过一次遍历，每一天记录当天以及之前的买入价最低点和当天为止的最大利润。使用 minPrice 存放当天及之前的最低点价格，初始为无限大确保能在对比是赋值更小的值。使用 maxPrice 存放最大利润，如果当天价格没达到最低点，则计算当天与最低点的差值，并且与当前的 maxPrice 作比较，取两者较大值作为下一天的临时最大利润。 参考其中一个题解的动图 link 代码： 12345678910111213141516171819/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; // 价格最低点和最大利润 let minPrice = Infinity, maxPrice = 0; for (let i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; minPrice) &#123; // 如果当天价格比最低点要小，把当天价格赋值给最低点 minPrice = prices[i]; &#125; else &#123; // 取出当天价格与最低点的差值与临时最大利润做对比，取出两者最大值作为新的临时最大利润 maxPrice = Math.max(prices[i] - minPrice, maxPrice); &#125; &#125; return maxPrice;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day08 - 零钱兑换","slug":"leetcodeday08","date":"2020-03-07T16:00:00.000Z","updated":"2020-03-08T12:01:23.447Z","comments":true,"path":"2020/03/08/leetcodeday08/","link":"","permalink":"https://cirnobreak.github.io/2020/03/08/leetcodeday08/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/coin-change/ 题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11输出: 3 解释: 11 &#x3D; 5 + 5 + 1 示例 2: 12输入: coins &#x3D; [2], amount &#x3D; 3输出: -1 解题思路这道题涉及到动态规划，由于本人没接触过动态规划相关的，理解起来比较困难，等学习相关知识后再补充，下面简单说下代码思路，主要是参考 link 的迭代解法。 思路参考下图： 从0开始一直到amount一直分解问题。dp[i] = x 表示当前目标金额为i时，至少需要 x 枚硬币。数组初始化为 amount + 1 是因为凑成 amount 枚硬币最多只能等于 amount（全用1元硬币的情况），所以初始为 amount + 1 相当于初始化为正无穷，便于后续取最小值。 代码: ```javascript/** @param {number[]} coins @param {number} amount @return {number} /var coinChange = function(coins, amount) {if (amount === 0) { return 0;}const dp = Array(amount + 1).fill(Infinity);dp[0] = 0;for (let i = 1; i &lt; dp.length; i++) { for (let j = 0; j &lt; coins.length; j++) { if (i - coins[j] &gt;= 0) { dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1); } }} return dp[dp.length - 1] === Infinity ? -1 : dp[dp.length - 1];};","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day07 - 队列的最大值","slug":"leetcodeday07","date":"2020-03-06T16:00:00.000Z","updated":"2020-03-08T11:45:34.451Z","comments":true,"path":"2020/03/07/leetcodeday07/","link":"","permalink":"https://cirnobreak.github.io/2020/03/07/leetcodeday07/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/ 题目描述请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例 1： 1234输入: [&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[1],[2],[],[],[]]输出: [null,null,null,2,1,2] 示例 2： 1234输入: [&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[],[]]输出: [null,-1,-1] 解题思路双端队列初始化两个队列，原始队列 queue ，就是正常的进队出队，另一个是辅助数组 deque ，存放最大值和小于最大值的值(降序排序)。 进队(push_back)时，当前值 push 进原始队列 queue，同时拿当前值与辅助队列最后一个值进行对比，如果比最后一个值大，删掉最后一个值，继续上述操作直到数组为空或者找到比当前值大的值，push进辅助队列；如果开始就比当前值大或者开始 deque就为空，push 进deque。辅助队列主要是为了方便取最大值和pop_front的时候假如删除最大值可以保证取到下一轮的最大值。 出队(pop_front)时，直接删除原始队列 queue的第一个值即可，同事确保第一个值是否与 辅助队列 deque第一个值相等，如果相等，同时删掉 deque 的第一个值。 取最大值 max_value，根据上述可以知道直接取辅助队列 deque 第一个值即可，辅助队列为空时返回-1。 参考 leetcode其中一个题解的动图 link 代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var MaxQueue = function() &#123; // 原始队列，只处理进队出队 this.queue = []; // 辅助队列，存放最大值和较大值(降序排序) this.deque = [];&#125;;/** * @return &#123;number&#125; */MaxQueue.prototype.max_value = function() &#123; if (this.deque.length) &#123; return this.deque[0]; &#125; return -1;&#125;;/** * @param &#123;number&#125; value * @return &#123;void&#125; */MaxQueue.prototype.push_back = function(value) &#123; // 直接向原始队列存值 this.queue.push(value); // 从辅助队列末尾开始对比，删掉比当前值小的值 while (this.deque.length &amp;&amp; this.deque[this.deque.length - 1] &lt; value) &#123; this.deque.pop(); &#125; // 往辅助队列存值 this.deque.push(value);&#125;;/** * @return &#123;number&#125; */MaxQueue.prototype.pop_front = function() &#123; if (this.queue.length) &#123; // 删掉原始队列第一个值 const val = this.queue.shift(); // 如果辅助队列第一个值跟当前值相等，删掉辅助队列第一个值 if (val === this.deque[0]) &#123; this.deque.shift(); &#125; return val; &#125; return -1;&#125;;/** * Your MaxQueue object will be instantiated and called as such: * var obj = new MaxQueue() * var param_1 = obj.max_value() * obj.push_back(value) * var param_3 = obj.pop_front() */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day06 - 和为s的连续正数序列","slug":"leetcodeday06","date":"2020-03-05T16:00:00.000Z","updated":"2020-03-06T15:34:49.277Z","comments":true,"path":"2020/03/06/leetcodeday06/","link":"","permalink":"https://cirnobreak.github.io/2020/03/06/leetcodeday06/","excerpt":"","text":"题目地址[https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) 题目描述输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例 1： 12输入：target &#x3D; 9输出：[[2,3,4],[4,5]] 示例 2： 12输入：target &#x3D; 15输出：[[1,2,3,4,5],[4,5,6],[7,8]] 解题思路暴力枚举暴力枚举的思路比较简单，注意遍历索引上限为target / 2向下取整即可。 代码： 1234567891011121314151617181920212223/** * @param &#123;number&#125; target * @return &#123;number[][]&#125; */var findContinuousSequence = function(target) &#123; let arr = []; let sum = 0; for (let i = 0; i &lt; target / 2; i++) &#123; for (let j = i + 1; j &lt; target; j++) &#123; sum += j; if (sum &gt; target) &#123; sum = 0; break; &#125; else if (sum === target) &#123; sum = 0; const newArr = (new Array(j - i)).fill(0).map((v, index) =&gt; i + index + 1); arr.push(newArr); break; &#125; &#125; &#125; return arr;&#125;; 滑动窗口滑动窗口简单来说就是两个指针所围成的区域，而两个指针通过移动会引起这个范围变动，从而引起这个范围(窗口)滑动，即滑动窗口。引用一下 leetcode 上一个题解的图 link: 首先声明两个指针 i j 分别负责左右边界，sum 记录 i 到 j 之间的和，arr 用于存储符合条件的数组集。 当 sum &lt; target时，右边界指针向右移动，并且 sum 加上有边界指针右移一位的值。 当 sum &gt; target时，左边界指针向右移动，并且 sum 减去当前左边界指针的值。 当 sum === target，把符合的结果集存到arr，并且 sum 减去左边界指针的值，左边界指针向右移动。 代码： 123456789101112131415161718192021222324252627282930/** * @param &#123;number&#125; target * @return &#123;number[][]&#125; */var findContinuousSequence = function(target) &#123; // 左边界指针从1开始，右边界指针为2，所以初始 sum 值为3 let i = 1, j = 2, sum = 3, arr = []; // 从头开始遍历，因为 (target / 2) + (target / 2 + 1)必然是大于 target的，所以 i 不超过 target / 2 while (i &lt;= (target / 2)) &#123; if (sum &lt; target) &#123; // 右边界指针右移 sum += (j + 1); j++ &#125; else if (sum &gt; target) &#123; // 左边界指针右移 sum -= i; i++; &#125; else &#123; // 存放结果集，左边界指针右移 const res = (new Array((j + 1) - i)).fill(0).map((v, index) =&gt; i + index); arr.push(res) sum -= i; i++; &#125; &#125; return arr;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day05 - 分糖果 II","slug":"leetcodeday05","date":"2020-03-04T16:00:00.000Z","updated":"2020-03-05T13:46:29.195Z","comments":true,"path":"2020/03/05/leetcodeday05/","link":"","permalink":"https://cirnobreak.github.io/2020/03/05/leetcodeday05/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/distribute-candies-to-people/ 题目描述排排坐，分糖果。 我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。 给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。 然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。 重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。 返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。 示例 1： 1234567输入：candies &#x3D; 7, num_people &#x3D; 4输出：[1,2,3,1]解释：第一次，ans[0] +&#x3D; 1，数组变为 [1,0,0,0]。第二次，ans[1] +&#x3D; 2，数组变为 [1,2,0,0]。第三次，ans[2] +&#x3D; 3，数组变为 [1,2,3,0]。第四次，ans[3] +&#x3D; 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。 示例 2： 1234567输入：candies &#x3D; 10, num_people &#x3D; 3输出：[5,2,3]解释：第一次，ans[0] +&#x3D; 1，数组变为 [1,0,0]。第二次，ans[1] +&#x3D; 2，数组变为 [1,2,0]。第三次，ans[2] +&#x3D; 3，数组变为 [1,2,3]。第四次，ans[0] +&#x3D; 4，最终数组变为 [5,2,3]。 解题思路暴力枚举这道题比较简单，只需要记录好每次要分的糖果数即可，每分一次减一次剩余糖果数。注意分到最后一个小朋友的时候的数量肯定是小于等于剩余糖果数，所以简单的处理方式就是每次分都判断一下当前剩余的糖果数跟要分的糖果数哪个更少就分哪个即可。 代码 1234567891011121314151617181920/** * @param &#123;number&#125; candies * @param &#123;number&#125; num_people * @return &#123;number[]&#125; */var distributeCandies = function (candies, num_people) &#123; // 初始化数组 const arr = Array.from(&#123; length: num_people &#125;).fill(0); // 每次要分的糖果数 let i = 1; while (candies != 0) &#123; // i % num_people 用于获取当前分到的小朋友的下标 // 由于要判断是否分到最后一个小朋友，所以这里判断要分的糖果数和剩下的糖果数哪个数量更少，就分哪个 arr[i % num_people] += Math.min(i, candies) candies -= Math.min(i, candies) // 新一轮分糖果开始，要分的糖果数量 + 1 i++ &#125; return arr;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day04 - 腐烂的橘子","slug":"leetcodeday04","date":"2020-03-03T16:00:00.000Z","updated":"2020-03-06T14:45:06.077Z","comments":true,"path":"2020/03/04/leetcodeday04/","link":"","permalink":"https://cirnobreak.github.io/2020/03/04/leetcodeday04/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/rotting-oranges/ 题目描述在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 示例 1： 示例1 12输入：[[2,1,1],[1,1,0],[0,1,1]]输出：4 示例 2： 123输入：[[2,1,1],[0,1,1],[1,0,1]]输出：-1解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。 示例 3： 123输入：[[0,2]]输出：0解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。 解题思路广度优先搜索(BFS) indexQueue 用于存放感染的橘子的下标，freshNum 记录新鲜的橘子数量， mins 记录感染的分钟数。 首先遍历一遍 grid 数组，找出所有感染的橘子(2)的下标[i, j]，存放到 indexQueue 数组，供 BFS 使用，同时记录新鲜橘子的数量。 开始遍历 indexQueue，每次取出 indexQueue 第一个对应的值的下标，开始感染(四个方向都感染)。如果遇到新鲜的橘子，把该橘子的下标存进新的队列 newIndexQueue 提供后续遍历感染并把对应的值赋值为2，同时新鲜橘子的数量 - 1，一轮结束 mins + 1，把 newIndexQueue 赋值给indexQueue，开始新一轮的感染。 最后，如果还有新鲜的橘子(freshNum &gt; 0)，返回 -1，否则返回感染过程的分钟数 mins。 引用一下其中一个 leetcode 题解的动图 link： 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var orangesRotting = function(grid) &#123; // 初始的感染橘子下标队列 let indexQueue = []; // 新鲜橘子数量 let freshNum = 0; // 感染的分钟数 let mins = 0; // 遍历橘子二维数组 for(let i = 0; i &lt; grid.length; i++) &#123; for(let j = 0; j &lt; grid[0].length; j++) &#123; // 把感染橘子的下标存到 indexQueue if (grid[i][j] === 2) &#123; indexQueue.push([i, j]); &#125; // 记录新鲜橘子数量 if (grid[i][j] === 1) &#123; freshNum++; &#125; &#125; &#125; while (indexQueue.length &gt; 0 &amp;&amp; freshNum &gt; 0) &#123; // 下一轮的indexQueue let newIndexQueue = []; while (indexQueue.length &gt; 0) &#123; const badOrangeIndex = indexQueue.shift(); // 当前橘子感染的橘子数 let curInfectNum = 0; // 取下标 const [r, c] = badOrangeIndex; // 往上感染 if (r &gt; 0 &amp;&amp; grid[r - 1][c] === 1) &#123; grid[r - 1][c] = 2; curInfectNum++; newIndexQueue.push([r - 1, c]) &#125; // 往左感染 if (c &gt; 0 &amp;&amp; grid[r][c - 1] === 1) &#123; grid[r][c - 1] = 2; curInfectNum++; newIndexQueue.push([r, c - 1]) &#125; // 往下感染 if (r &lt; grid.length - 1 &amp;&amp; grid[r + 1][c] === 1) &#123; grid[r + 1][c] = 2; curInfectNum++; newIndexQueue.push([r + 1, c]) &#125; // 往右感染 if (c &lt; grid[0].length - 1 &amp;&amp; grid[r][c + 1] === 1) &#123; grid[r][c + 1] = 2; curInfectNum++; newIndexQueue.push([r, c + 1]) &#125; // 减少新鲜橘子数量 freshNum -= curInfectNum; &#125; // 一轮结束 mins++; // 准备开始下一轮遍历 indexQueue = newIndexQueue; &#125; if (freshNum !== 0) &#123; return -1; &#125; return mins;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day03 - 合并排序的数组","slug":"leetcodeday03","date":"2020-03-02T16:00:00.000Z","updated":"2020-03-05T13:40:36.975Z","comments":true,"path":"2020/03/03/leetcodeday03/","link":"","permalink":"https://cirnobreak.github.io/2020/03/03/leetcodeday03/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/sorted-merge-lcci/ 题目描述给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。 初始化 A 和 B 的元素数量分别为 m 和 n。 示例: 输入: 1234A &#x3D; [1,2,3,0,0,0], m &#x3D; 3B &#x3D; [2,5,6], n &#x3D; 3输出: [1,2,2,3,5,6] 解题思路api 法api 法比较简单，就是直接把 A 数组删掉从下标 m - 1 开始的所有元素，然后 B 数组截取前 n 个元素后插入 A 数组，最后对 A 数组进行一次排序。 代码： 1234567891011/** * @param &#123;number[]&#125; A * @param &#123;number&#125; m * @param &#123;number[]&#125; B * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify A in-place instead. */var merge = function(A, m, B, n) &#123; A.splice(m, A.length - m, ...B.slice(0, n)); A.sort((a, b) =&gt; a - b);&#125;; 双指针法题目给出的条件是，A 的末端有足够的缓冲空间容纳 B，由此可以初始化两个指针，位置分别指向第 m n 位置，也就是下标为 m - 1 和 n - 1，从数组 A 末端开始填充数据，即一直给数组 A 下标为 m + n - 1 赋值两个指针对应下标的最大值。 举例: A = [1,2,3,0,0,0], m = 3B = [2,5,6], n = 3 时 第一轮， A[3 - 1] 与 B[3 - 1] 比较，此时 A[3 - 1] &lt; B[3 - 1]，把 B[3 - 1]的值赋值到 A[3 + 3 - 1]，B 指针对应下标 - 1第二轮, A[3 - 1] 与 B[2 - 1] 比较，此时 A[3 - 1] &lt; B[2 - 1]，把 B[3 - 1]的值赋值到 A[3 + 2 - 1]，B 指针对应下标 - 1第三轮, A[3 - 1] 与 B[1 - 1] 比较，此时 A[3 - 1] &gt; B[1 - 1]，把 A[3 - 1]的值赋值到 A[3 + 1 - 1]，A 指针对应下标 - 1… 代码： 123456789101112131415161718192021222324252627var merge = function(A, m, B, n) &#123; // 初始化 A 和 B 数组指针的下标和赋值位置下标 let mIndex = m - 1, nIndex = n - 1, cur = m + n - 1; while (mIndex &gt;= 0 || nIndex &gt;= 0) &#123; if (mIndex === -1) &#123; // 此时 A 数组已经挪完，B数组继续往前挪 A[cur] = B[nIndex]; nIndex--; &#125; else if (nIndex === -1) &#123; // 此时 B 数组已经挪完，A数组继续往前挪 A[cur] = A[mIndex]; mIndex--; &#125; else if (A[mIndex] &gt; B[nIndex]) &#123; // 此时 A 数组指针对应的值比 B 数组指针的值大，赋值后 A 指针往前挪 A[cur] = A[mIndex]; mIndex--; &#125; else &#123; // 此时 B 数组指针对应的值大于或者等于 A 数组指针的值，赋值后 B 指针往前挪 A[cur] = B[nIndex]; nIndex--; &#125; // 一轮结束后赋值的下标往前挪 cur--; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day02 - 反转链表","slug":"leetcodeday02","date":"2020-03-01T16:00:00.000Z","updated":"2020-03-05T13:40:22.538Z","comments":true,"path":"2020/03/02/leetcodeday02/","link":"","permalink":"https://cirnobreak.github.io/2020/03/02/leetcodeday02/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/reverse-linked-list/ 题目描述反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题思路非递归解法遍历整个链表，借助变量 pre 记录前驱结点(初始为 null)，把当前结点(current)的 next 连接到 pre，即 current.next = pre。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 定义单链表 * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; // 链表为空或者只有一个元素时直接返回head if (!head || !head.next) &#123; return head; &#125; // 初始化，先从head开始遍历，由于链表head的前驱为null，所以pre初始时为null let current = head, pre = null; while (current) &#123; // 拷贝一份当前结点的后继结点 const next = current.next; // 把当前结点的后继结点连接到前驱结点(反转) // 比如, null-&gt;head-&gt;next 变成了 null&lt;-head current.next = pre; /* * 初始: * pre = null, current = null&lt;-head * 下一回: * pre = null&lt;-head，current = head.next * 再下一回 * pre = null&lt;-head&lt;-head.next，current = head.next.next * ... */ // 把当前结点赋值到前驱结点，准备下一次链表反转 pre = current; // 把反转前的 current.next 的备份作为当前结点，准备下一次链表反转 current = next; &#125; return pre;&#125;; 递归解法递归解法代码实现比较简单，就是通过递归，直到触发结束条件，然后从尾部一直反转连接到头部。也就是从链表尾部开始，每一次都先把自己与后继结点连接断掉，然后后继结点指向自己，直到连接到头部为止。 代码： 1234567891011121314151617181920/** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; // 递归结束条件 if (!head || !head.next) &#123; return head; &#125; let next = head.next, newList = reverseList(head.next); // head断开与后继结点的连接 head.next = null; // 后继结点的后继结点连接到head next.next = head; return newList;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"leetcode day01 - 用队列实现栈","slug":"leetcodeday01","date":"2020-02-29T16:00:00.000Z","updated":"2020-03-05T13:39:55.435Z","comments":true,"path":"2020/03/01/leetcodeday01/","link":"","permalink":"https://cirnobreak.github.io/2020/03/01/leetcodeday01/","excerpt":"","text":"题目地址https://leetcode-cn.com/problems/implement-stack-using-queues/ 题目描述使用队列实现栈的下列操作： push(x) – 元素 x 入栈pop() – 移除栈顶元素top() – 获取栈顶元素empty() – 返回栈是否为空 注意: 你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 解题思路简单解法(非 api)用一个数组模拟栈(LIFO)，数组末尾为栈顶，数组头为栈底。 实现 top 只需获取数组末尾元素。 实现 push 只需在数组末尾添加元素。 pop 的实现，首先是获取数组最后一个元素，并且需要对数组长度减一来实现数组删除最后一个元素的操作。 实现 empty 只需要判断数组是否为空即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 初始化 */var MyStack = function() &#123; this.stack = [];&#125;;/** * 把元素 x 压入栈 * @param &#123;number&#125; x * @return &#123;void&#125; */MyStack.prototype.push = function(x) &#123; this.stack[this.stack.length] = x;&#125;;/** * 移出栈顶元素并且返回该元素 * @return &#123;number&#125; */MyStack.prototype.pop = function() &#123; const ele = this.stack[this.stack.length - 1]; this.stack.length = this.stack.length - 1; return ele;&#125;;/** * 直接获取栈顶元素 * @return &#123;number&#125; */MyStack.prototype.top = function() &#123; return this.stack[this.stack.length - 1];&#125;;/** * 返回栈是否为空的布尔值 * @return &#123;boolean&#125; */MyStack.prototype.empty = function() &#123; if (this.stack.length === 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * var obj = new MyStack() * obj.push(x) * var param_2 = obj.pop() * var param_3 = obj.top() * var param_4 = obj.empty() */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cirnobreak.github.io/tags/leetcode/"}]},{"title":"[译]如何使用React Hooks获取数据?","slug":"hooksfetchdata","date":"2019-03-13T16:00:00.000Z","updated":"2020-03-07T14:02:30.543Z","comments":true,"path":"2019/03/14/hooksfetchdata/","link":"","permalink":"https://cirnobreak.github.io/2019/03/14/hooksfetchdata/","excerpt":"","text":"原文链接: How to fetch data with React Hooks?原文作者: RWieruch 在这篇教程中，我们会让你明白如何通过state和effect这两个 hooks 来获取数据。我们会使用广为人知的Hacker News API来获取科技世界的流行文章。你也可以实现你的custom hook(自定义钩子),它可以在你的应用程序任何地方复用，或者发布到 npm 上作为一个独立的 npm 包。 如果你不知道这些 React 新特性，你也可以阅读introduction to React Hooks这篇文章。如果你想查看这个项目代码，点击这个Github 仓库的链接。 NOTE: 在未来，React Hooks 不适合用于在 React 中获取数据。取而代之的是一个叫 Suspense 的新特性。尽管如此，文章以下内容仍然对于学习关于 state 跟 effect hooks 有帮助。 使用 React Hooks 获取数据如果你对 React 获取数据不熟悉，可以阅读extensive data fetching in React article，它会告诉你如何通过 React 的 class component 来获取数据、怎样使用Render Props 组件和高阶组件来实现复用，还有它是怎样解决错误处理和加载 spinner 的。在这篇文章，我们会给你展示如何在函数式组件(functional component)中使用 React Hooks 来实现上述内容。 1234567891011121314151617import React, &#123; useState &#125; from \"react\";function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); return ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default App; App 组件展示了一个 items 列表(hits = Hacker News 文章)。状态和状态更新的函数来源于叫做useState的状态钩子，它负责管理我们将为 App 组件获取的数据的本地状态。表示 data 的初始状态是一个对象里面属性名为 hits 的空数组，目前没有任何人为 data 设置任何状态(state)。 我们将使用axios来获取数据，但至于是否使用其他获取数据的库或者浏览器原生的 fetch API 将由你来决定。如果你没有安装 axios，你可以在命令行输入npm install axios，然后使用 effect hooks 来实现数据获取。 1234567891011121314151617181920212223242526import React, &#123; useState, useEffect &#125; from \"react\";import axios from \"axios\";function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); useEffect(async () =&gt; &#123; const result = await axios( \"http://hn.algolia.com/api/v1/search?query=redux\" ); setData(result.data); &#125;); return ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default App; 名为 useEffect 的 effect hook，用于使用 axios 从 API 获取数据，并且使用 state hook 的更新函数(setData)把数据存放到组件内的本地 state。Promise resolving 会在 aysnc/await 中进行。 然而，当你运行你的应用程序时，你会陷入一个恶性循环。组件挂载(mount)的时候 effect hook 会运行，但组件更新(update)的时候会再次运行。它将一次又一次地获取数据。这是一个 bug 并且需要预防。我们只需要在组件挂载的时候获取数据。这就是为什么可以使用一个空数组作为 effect hook 的第二个参数，来避免组件更新的时候激活它，并且只在组件挂载的时候激活它的原因。 1234567891011121314151617181920212223242526import React, &#123; useState, useEffect &#125; from \"react\";import axios from \"axios\";function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); useEffect(async () =&gt; &#123; const result = await axios( \"http://hn.algolia.com/api/v1/search?query=redux\" ); setData(result.data); &#125;, []); return ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default App; 第二个参数可以定义 hook 依赖的所有变量(在这个数组中分配)。如果其中一个参数改变，hook 会再次运行。如果数组内的变量为空，组件更新的时候 hook 不会运行，因为它不会去监听任何变量的变化。 还有最后一个问题。在代码中，我们使用 async/await 从第三方 API 获取数据。根据文档的描述，每一个使用 async 的函数注解都应该返回一个隐式 promise。*”async 函数声明定义一个异步函数，它返回一个 AsyncFunction 对象。异步函数是通过事件循环(event loop)异步操作的函数,它使用隐式 promise 返回结果。”然而，一个 effect hook 它应该不返回任何东西或者返回一个简洁的函数。这就是为什么你会看到在开发者模式会有如下的 console log:*07:41:22.910 index.js:1452 Warning: useEffect function must return a cleanup function or nothing. Promises and useEffect(async () =&gt; …) are not supported, but you can call an async function inside an effect.**。这就是为什么不允许直接在useEffect里面使用 async 函数的原因。我们换种方式在 effect hook 中使用 async 函数。 123456789101112131415161718192021222324252627282930import React, &#123; useState, useEffect &#125; from \"react\";import axios from \"axios\";function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; const result = await axios( \"http://hn.algolia.com/api/v1/search?query=redux\" ); setData(result.data); &#125;; fetchData(); &#125;, []); return ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default App; 简单来说，就是使用 React Hooks 获取数据。如果你对错误处理、加载指示、如何触发表单数据获取，以及如何实现可复用的数据获取 hook 这些内容感兴趣，请继续阅读文章。 如何以编程的方式/手动地触发 hook太棒了，一旦组件挂载后，我们就可以获取到数据了。但是，如果我们输入某个字段来告诉 API 我们对哪个话题感兴趣呢？将”Redux”作为默认查询(query)，但关于”React”的话题呢？让我们来实现一个 input 元素(element)来使得某人可以获取除了”Redux”之外的话题的相关数据。 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Fragment, useState, useEffect &#125; from \"react\";import axios from \"axios\";function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(\"redux\"); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; const result = await axios( \"http://hn.algolia.com/api/v1/search?query=redux\" ); setData(result.data); &#125;; fetchData(); &#125;, []); return ( &lt;Fragment&gt; &lt;input type=\"text\" value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/Fragment&gt; );&#125;export default App; 此时，两个状态(state)是彼此独立的，但现在你希望将它们耦合起来，只通过输入字段指定的查询(query)来获取数据。通过以下修改，组件会在挂载后按照查询(query)获取所有相关文章。 12345678910111213141516171819202122function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState('redux'); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; const result = await axios( `http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`, ); setData(result.data); &#125;; fetchData(); &#125;, []); return ( ... );&#125;export default App; 此时我们会发现少了一样东西: 当你尝试在在输入框输入一些东西的时候，你会发现，在组件挂载后触发的 effect hook 获取了数据之后，就不会再获取数据了。这是因为你在 effect hook 的把一个空数组作为第二个参数，而 effect hook 没有依赖的变量，所以它只在组件挂载的时候触发。然而，现在的 effect hook 需要依赖查询(query)。一旦查询(query)改变，数据请求应该再次触发。 12345678910111213141516171819202122function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState('redux'); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; const result = await axios( `http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`, ); setData(result.data); &#125;; fetchData(); &#125;, [query]); return ( ... );&#125;export default App; 一旦你改变了输入框里面的值，数据就会重新获取。但这会引发另一个问题: 每输入一个字符都会触发数据获取请求。不如提供一个按钮，来手动触发 hook? 1234567891011121314151617181920212223242526272829303132333435363738function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(\"redux\"); const [search, setSearch] = useState(\"\"); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; const result = await axios( `http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;` ); setData(result.data); &#125;; fetchData(); &#125;, [query]); return ( &lt;Fragment&gt; &lt;input type=\"text\" value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=\"button\" onClick=&#123;() =&gt; setSearch(query)&#125;&gt; Search &lt;/button&gt; &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/Fragment&gt; );&#125; 现在，我们使 effect hook 依赖于搜索(search)的状态，而不是每次输入都波动地改变查询(query)的状态。一旦用户点击了按钮，新的搜索(search)状态会被设置，并手动触发了 effect hook。 1234567891011121314151617181920212223function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState('redux'); const [search, setSearch] = useState('redux'); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; const result = await axios( `http://hn.algolia.com/api/v1/search?query=$&#123;search&#125;`, ); setData(result.data); &#125;; fetchData(); &#125;, [search]); return ( ... );&#125;export default App; 此外，搜索(search)状态的初始值会被设置为与查询(query)状态相同的状态，因为组件也在挂载时获取数据，因此结果应该与输入框的值对应。然而，具有相似的查询(query)和搜索(search)状态会令人困惑。为何不把实际的 URL 设置为状态而不是设置为搜索(search)状态？ 12345678910111213141516171819202122232425262728293031323334353637383940414243function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(\"redux\"); const [url, setUrl] = useState( \"http://hn.algolia.com/api/v1/search?query=redux\" ); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; const result = await axios(url); setData(result.data); &#125;; fetchData(); &#125;, [url]); return ( &lt;Fragment&gt; &lt;input type=\"text\" value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=\"button\" onClick=&#123;() =&gt; setUrl(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`) &#125; &gt; Search &lt;/button&gt; &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/Fragment&gt; );&#125; 这是使用 effect hook 来获取隐式程序数据的情况。你可以决定 effect hook 取决于哪个状态。一旦你在点击或者在其他副作用的情况下设置状态，effect hook 会重新运行。在这种情况下，如果 URL 状态改变了，effect hook 会重新从 API 请求数据。 使用 React Hooks 实现加载指示器让我们为数据获取请求引入一个加载指示器。它只是另一个由 state hook 管理的状态。loading 标志用于在 App 组件中呈现加载指示器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React, &#123; Fragment, useState, useEffect &#125; from \"react\";import axios from \"axios\";function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(\"redux\"); const [url, setUrl] = useState( \"http://hn.algolia.com/api/v1/search?query=redux\" ); const [isLoading, setIsLoading] = useState(false); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; setIsLoading(true); const result = await axios(url); setData(result.data); setIsLoading(false); &#125;; fetchData(); &#125;, [url]); return ( &lt;Fragment&gt; &lt;input type=\"text\" value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=\"button\" onClick=&#123;() =&gt; setUrl(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`) &#125; &gt; Search &lt;/button&gt; &#123;isLoading ? ( &lt;div&gt;Loading ...&lt;/div&gt; ) : ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125; &lt;/Fragment&gt; );&#125;export default App; 在组件挂载或者 URL 状态改变的时候，一旦 effect hook 调用数据获取方法，加载(loading)状态就会被设置为 true。一旦请求完成，加载(loading)状态就会被再次设置为 false。 使用 React Hooks 进行错误处理那如何使用一个 React Hook 来进行数据获取时的错误处理？错误只是 state hook 的另一种初始状态。一旦错误(error)状态存在，App 组件会给用户渲染一个错误的反馈。当使用 async/await 的时候，通常使用 try/catch 块进行错误处理。你也可以在 effect hook 里面使用: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import React, &#123; Fragment, useState, useEffect &#125; from \"react\";import axios from \"axios\";function App() &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [query, setQuery] = useState(\"redux\"); const [url, setUrl] = useState( \"http://hn.algolia.com/api/v1/search?query=redux\" ); const [isLoading, setIsLoading] = useState(false); const [isError, setIsError] = useState(false); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; setIsError(false); setIsLoading(true); try &#123; const result = await axios(url); setData(result.data); &#125; catch (error) &#123; setIsError(true); &#125; setIsLoading(false); &#125;; fetchData(); &#125;, [url]); return ( &lt;Fragment&gt; &lt;input type=\"text\" value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=\"button\" onClick=&#123;() =&gt; setUrl(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`) &#125; &gt; Search &lt;/button&gt; &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/div&gt;&#125; &#123;isLoading ? ( &lt;div&gt;Loading ...&lt;/div&gt; ) : ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125; &lt;/Fragment&gt; );&#125;export default App; effect hook 每次运行的时候，错误(error)状态都会被重设一遍。这是非常有用的，因为在请求失败的时候，用户可能想要再次尝试获取，这时候应该重置错误。为了强制实现出错的情况，你可以把 URL 修改为一些无效的内容，然后检查一下错误信息是否成功显示。 使用表单和 React 获取数据如何使用合适的表单来获取数据？到目前为止，我们有输入框和按钮的组合。一旦引入更多的输入元素，你可能会想要用表单元素来包裹它们。此外，表单还可以触发键盘上的”Enter”来触发按钮。 123456789101112131415161718192021222324function App() &#123; ... return ( &lt;Fragment&gt; &lt;form onSubmit=&#123;() =&gt; setUrl(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`) &#125; &gt; &lt;input type=\"text\" value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=\"submit\"&gt;Search&lt;/button&gt; &lt;/form&gt; &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/div&gt;&#125; ... &lt;/Fragment&gt; );&#125; 但是现在点击提交按钮的时候，浏览器会重新加载，因为这是提交表单时浏览器的固有行为。为了防止这种默认行为，我们可以在 React 事件中调用一个函数。在 React 的 class component 也是这样实现的。 12345678910111213141516171819202122232425262728function App() &#123; ... const doFetch = () =&gt; &#123; setUrl(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`); &#125;; return ( &lt;Fragment&gt; &lt;form onSubmit=&#123;event =&gt; &#123; doFetch(); event.preventDefault(); &#125;&#125;&gt; &lt;input type=\"text\" value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=\"submit\"&gt;Search&lt;/button&gt; &lt;/form&gt; &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/div&gt;&#125; ... &lt;/Fragment&gt; );&#125; 现在，当你点击提交按钮的时候，浏览器也不会重新加载了。它和以前一样，但这次使用的是表单而不是原来的输入框和按钮的组合。你也可以在键盘上按上”Enter”触发。 自定义一个数据获取 hook为了抽离一个数据获取的自定义 hook，将属于数据获取的所有内容，除了属于输入框的查询(query)状态，但包括加载指示器和错误处理的，移动到它自己的函数里。还要确保从 App 组件中使用函数返回所有必要的变量。 123456789101112131415161718192021222324252627282930313233const useHackerNewsApi = () =&gt; &#123; const [data, setData] = useState(&#123; hits: [] &#125;); const [url, setUrl] = useState( \"http://hn.algolia.com/api/v1/search?query=redux\" ); const [isLoading, setIsLoading] = useState(false); const [isError, setIsError] = useState(false); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; setIsError(false); setIsLoading(true); try &#123; const result = await axios(url); setData(result.data); &#125; catch (error) &#123; setIsError(true); &#125; setIsLoading(false); &#125;; fetchData(); &#125;, [url]); const doFetch = () =&gt; &#123; setUrl(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`); &#125;; return &#123; data, isLoading, isError, doFetch &#125;;&#125;; 现在，一个全新的 hook 可以再次在 App 组建中使用。 123456function App() &#123; const [query, setQuery] = useState(\"redux\"); const &#123; data, isLoading, isError, doFetch &#125; = useHackerNewsApi(); return &lt;Fragment&gt;...&lt;/Fragment&gt;;&#125; 接着，从doFetch函数外部传入 URL 状态: 1234567891011121314151617181920212223242526272829303132333435363738394041const useHackerNewsApi = () =&gt; &#123; ... useEffect( ... ); const doFetch = url =&gt; &#123; setUrl(url); &#125;; return &#123; data, isLoading, isError, doFetch &#125;;&#125;;function App() &#123; const [query, setQuery] = useState('redux'); const &#123; data, isLoading, isError, doFetch &#125; = useHackerNewsApi(); return ( &lt;Fragment&gt; &lt;form onSubmit=&#123;event =&gt; &#123; doFetch( `http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`, ); event.preventDefault(); &#125;&#125; &gt; &lt;input type=\"text\" value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=\"submit\"&gt;Search&lt;/button&gt; &lt;/form&gt; ... &lt;/Fragment&gt; );&#125; 初始状态也可以是通用的。简单地把它传递到新的自定义 hook: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React, &#123; Fragment, useState, useEffect &#125; from \"react\";import axios from \"axios\";const useDataApi = (initialUrl, initialData) =&gt; &#123; const [data, setData] = useState(initialData); const [url, setUrl] = useState(initialUrl); const [isLoading, setIsLoading] = useState(false); const [isError, setIsError] = useState(false); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; setIsError(false); setIsLoading(true); try &#123; const result = await axios(url); setData(result.data); &#125; catch (error) &#123; setIsError(true); &#125; setIsLoading(false); &#125;; fetchData(); &#125;, [url]); const doFetch = url =&gt; &#123; setUrl(url); &#125;; return &#123; data, isLoading, isError, doFetch &#125;;&#125;;function App() &#123; const [query, setQuery] = useState(\"redux\"); const &#123; data, isLoading, isError, doFetch &#125; = useDataApi(\"http://hn.algolia.com/api/v1/search?query=redux\", &#123; hits: [] &#125;); return ( &lt;Fragment&gt; &lt;form onSubmit=&#123;event =&gt; &#123; doFetch(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`); event.preventDefault(); &#125;&#125; &gt; &lt;input type=\"text\" value=&#123;query&#125; onChange=&#123;event =&gt; setQuery(event.target.value)&#125; /&gt; &lt;button type=\"submit\"&gt;Search&lt;/button&gt; &lt;/form&gt; &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/div&gt;&#125; &#123;isLoading ? ( &lt;div&gt;Loading ...&lt;/div&gt; ) : ( &lt;ul&gt; &#123;data.hits.map(item =&gt; ( &lt;li key=&#123;item.objectID&#125;&gt; &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125; &lt;/Fragment&gt; );&#125;export default App; 这就是使用自定义 hook 获取数据的原因。hook 本身不知道任何跟 API 相关的内容。它接收外部的所有参数，并且只管理必要的状态，比如数据(data)、加载(loading)、错误(error)状态。它将执行请求，并且给组件返回数据。 使用 Reducer Hook 请求数据到目前为止，我们已经使用了各种 state hook 来管理获取到的数据 - 数据(data)、加载(loading)和错误(error)状态。然而，不知何故，所有的这些状态都是由它们自身的 state hook 管理的，并且联系在一起，因为它们关心的是同样的问题。如你所见，它们都是在数据获取函数中使用的。能表明它们联系在一起的表现是它们是一个接一个地使用的(比如: setIsError, setIsLoading)。让我们把这三个用 Reducer Hook 结合起来。 Reducer Hook 返回一个状态(state)对象和一个修改状态(state)对象的函数。这个叫做 dispatch 的函数，带有一个含有类型(type)跟可选的载荷(payload)的动作(action)。所有的这些信息，在实际的 reducer 函数中使用 action 中的可选载荷(payload)和类型(type)，实现从以前的状态(state)提取一个全新的状态(state)的动作。让我们来看看这在代码中是如何工作的: 1234567891011121314151617181920212223import React, &#123; Fragment, useState, useEffect, useReducer,&#125; from 'react';import axios from 'axios';const dataFetchReducer = (state, action) =&gt; &#123; ...&#125;;const useDataApi = (initialUrl, initialData) =&gt; &#123; const [url, setUrl] = useState(initialUrl); const [state, dispatch] = useReducer(dataFetchReducer, &#123; isLoading: false, isError: false, data: initialData, &#125;); ...&#125;; Reducer Hook 将 reducer 函数和初始状态对象作为参数。在我们的例子中，数据(data)、加载(loading)和错误(error)状态的初始状态没有发生改变，但它们被聚合到一个由 reducer hook 管理的状态对象，而不是单独的一个 state hook。 12345678910111213141516171819202122232425262728293031const dataFetchReducer = (state, action) =&gt; &#123; ...&#125;;const useDataApi = (initialUrl, initialData) =&gt; &#123; const [url, setUrl] = useState(initialUrl); const [state, dispatch] = useReducer(dataFetchReducer, &#123; isLoading: false, isError: false, data: initialData, &#125;); useEffect(() =&gt; &#123; const fetchData = async () =&gt; &#123; dispatch(&#123; type: 'FETCH_INIT' &#125;); try &#123; const result = await axios(url); dispatch(&#123; type: 'FETCH_SUCCESS', payload: result.data &#125;); &#125; catch (error) &#123; dispatch(&#123; type: 'FETCH_FAILURE' &#125;); &#125; &#125;; fetchData(); &#125;, [url]); ...&#125;; 现在，当你获取数据的时候，dispatch 函数会把信息发送到 reducer 函数。使用 dispatch 函数发送对象需要有一个必要的type属性跟一个可选的payload属性。类型(type)告诉了 reducer 函数需要转换哪个状态(state)，reducer 还能从载荷(payload)中提取新的状态(state)。毕竟，我们只有三个状态转换:初始化获取进程、通知数据获取成功的结果、并通知数据获取错误的结果。 在自定义 hook 的末尾，像以前一样返回状态，因为我们有一个状态对象而不是独立的状态，状态对象返回的是一个被破坏的对象。这样，调用 useDataApi 这个自定义 hook 仍然可以访问data、isLoading、isError。 1234567891011121314151617const useDataApi = (initialUrl, initialData) =&gt; &#123; const [url, setUrl] = useState(initialUrl); const [state, dispatch] = useReducer(dataFetchReducer, &#123; isLoading: false, isError: false, data: initialData, &#125;); ... const doFetch = url =&gt; &#123; setUrl(url); &#125;; return &#123; ...state, doFetch &#125;;&#125;; 最后，同样重要的一点是，我们还没有实现 reducer 函数。它需要作用域三个不同的状态转化: FETCH_INIT、FETCH_SUCCESS、FETCH_FAILURE。每一个状态转换都需要返回一个新的状态(state)对象。让我们来看看如何使用 switch case 语句来实现这一点: 123456789101112const dataFetchReducer = (state, action) =&gt; &#123; switch (action.type) &#123; case \"FETCH_INIT\": return &#123; ...state &#125;; case \"FETCH_SUCCESS\": return &#123; ...state &#125;; case \"FETCH_FAILURE\": return &#123; ...state &#125;; default: throw new Error(); &#125;&#125;; reducer 函数可以通过参数访问当前状态和传入的操作。到目前为止，在 switch 里的 case 语句中，每个状态的转换只返回之前的状态。解构语句用于保持状态对象不可变 - 意味着状态(state)不能直接编译(mutated) - 执行最佳方案。现在，让我们覆盖一些当前状态返回的属性，以便在每次状态转换时修改状态: 12345678910111213141516171819202122232425const dataFetchReducer = (state, action) =&gt; &#123; switch (action.type) &#123; case \"FETCH_INIT\": return &#123; ...state, isLoading: true, isError: false &#125;; case \"FETCH_SUCCESS\": return &#123; ...state, isLoading: false, isError: false, data: action.payload &#125;; case \"FETCH_FAILURE\": return &#123; ...state, isLoading: false, isError: true &#125;; default: throw new Error(); &#125;&#125;; 现在，由 action 的 type 决定的每个状态转换都返回一个基于先前状态和可选的载荷(payload)的新状态。例如，在请求成功的情况下，载荷(payload)用于设置新状态对象的数据。 总之，Reducer Hook 确保了状态管理这一部分用自己的逻辑封装。通过提供 action 类型(type)和可选的载荷(payload)，你总会得到可预测的状态更改。另外，你永远不会遇到无效的状态。例如，以前你可能会意外地将isLoading和isError的状态设置为 true。在这种情况下，UI 应该显示什么？现在，由 reducer 函数定义的每个状态转换都会让另一个状态对象有效。 在 Effect Hook 中,中止数据获取在 React 中，即使组件已经卸载，但组件的状态仍会被设置，这是一个常见的问题。(比如: React Router 的导航)。我之前写过这个问题，它描述了如何防止在各种场景中为未挂载的组件设置状态。让我们看看如何防止在自定义 hook 中为数据获取设置状态。 1234567891011121314151617181920212223242526272829303132333435363738394041const useDataApi = (initialUrl, initialData) =&gt; &#123; const [url, setUrl] = useState(initialUrl); const [state, dispatch] = useReducer(dataFetchReducer, &#123; isLoading: false, isError: false, data: initialData &#125;); useEffect(() =&gt; &#123; let didCancel = false; const fetchData = async () =&gt; &#123; dispatch(&#123; type: \"FETCH_INIT\" &#125;); try &#123; const result = await axios(url); if (!didCancel) &#123; dispatch(&#123; type: \"FETCH_SUCCESS\", payload: result.data &#125;); &#125; &#125; catch (error) &#123; if (!didCancel) &#123; dispatch(&#123; type: \"FETCH_FAILURE\" &#125;); &#125; &#125; &#125;; fetchData(); return () =&gt; &#123; didCancel = true; &#125;; &#125;, [url]); const doFetch = url =&gt; &#123; setUrl(url); &#125;; return &#123; ...state, doFetch &#125;;&#125;; 每一个 Effect Hook 都会带有一个 clean up 函数，它会在组件卸载的时候执行。clean up 函数式 hook 返回的一个功能。在我们的例子中，我们使用一个名为didCancel的标记来让我们的数据获取逻辑知道组件的状态(已挂载/已卸载)。如果组件已经卸载，标记应该设置为true，这将导致在最终异步解决后无法设置组件状态。 Note: 实际上，数据获取并没有中止 - 这可以通过Axios Cancellation来实现 - 但对于已卸载的组件，不再执行状态转换。由于 Axios Cancellation 在我看来并不是最好的 API，阻止状态设置的布尔值标记也能起到作用。 你已经了解了如何在 React 中使用 state 和 effect hook 进行数据获取了。如果你对在使用 render props 和高阶组件的 class component(和 functional component)中获取数据感兴趣，你可以阅读我在文章开头提及到的文章。此外，我希望本文对学习 React Hooks 以及在实际场景中使用它们有所帮助。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cirnobreak.github.io/categories/Javascript/"}],"tags":[{"name":"React","slug":"React","permalink":"https://cirnobreak.github.io/tags/React/"},{"name":"Javascript","slug":"Javascript","permalink":"https://cirnobreak.github.io/tags/Javascript/"}]},{"title":"对深浅拷贝的简单理解","slug":"jscopy","date":"2019-02-26T16:00:00.000Z","updated":"2020-03-07T14:02:32.192Z","comments":true,"path":"2019/02/27/jscopy/","link":"","permalink":"https://cirnobreak.github.io/2019/02/27/jscopy/","excerpt":"","text":"深浅拷贝在前端开发中是必然会踩的一个坑，也是面试常考题。至于深浅拷贝为何会存在，主要是跟 JavaScript 的数据类型以及一些历史遗留的问题有关，下面来简单了解下这两者的区别以及如何实现。 为何需要深浅拷贝?首先，先从 JavaScript 的数据类型开始，在 JavaScript 中，有其中的内置类型，而这其中内置类型又分为两大类: 6 种原始类型(Boolean, Null, Undefined, Number, String, Symbol)和 Object。其中原始类型又叫基本类型，属于值类型，是按值访问的，因此可以操作保存在变量的实际的值；而 Object 属于引用类型，是按引用访问的，在操作对象的时候，实际上是操作对象的引用而不是对象的实际的值。 123456789let num1 = 5;let num2 = num1; // 5num2 = 3;console.log(num1, num2); // 5 3，指向不同数据let obj1 = new Object();let obj2 = obj1(); // &#123;&#125;obj2.a = \"ok\"; // &#123; a: 'ok' &#125;console.log(obj1, obj2); // &#123; a: 'ok' &#125; &#123; a: 'ok' &#125;， 指向同一份数据 可见，由于 Object 是引用类型，在吧 obj2 赋值给 obj1 的过程中，实际上，此时 obj1 跟 obj2 都指向了同一份数据(堆内存的同一块地址)，也就是说，在修改 obj2 的同时，也会对 obj1 造成影响。那我们要怎么样才能避免出现这样的问题?这时候就需要深/浅拷贝了。 浅拷贝按字面上的意思来理解，浅拷贝就是浅层的拷贝，在实际上是只对第一层进行拷贝。随着 ES6 的到来，我们有非常简单的浅拷贝解决方案。 使用 Object.assign() 123456let obj1 = &#123; a: \"ok\"&#125;;let obj2 = Object.assign(&#123;&#125;, obj1); // &#123; a: 'ok' &#125;obj2.b = \"yes\"; // &#123; a: 'ok', b: 'yes' &#125;console.log(obj1, obj2); // &#123; a: 'ok' &#125; &#123; a: 'ok', b: 'yes' &#125; 使用扩展运算符(…) 123456let obj1 = &#123; a: \"ok\"&#125;;let obj2 = &#123; ...obj1 &#125;;obj2.b = \"yes\"; // &#123; a: 'ok', b: 'yes' &#125;console.log(obj1, obj2); // &#123; a: 'ok' &#125; &#123; a: 'ok', b: 'yes' &#125; 传统 for 循环解决方案 1234567891011121314const shallowCopy = obj =&gt; &#123; let newObj = &#123;&#125;; for (let i of Ojbect.keys(obj)) &#123; newObj = obj[i]; &#125; return result;&#125;;let obj1 = &#123; a: \"ok\"&#125;;let obj2 = shallowCopy(obj1);obj2.b = \"yes\"; // &#123; a: 'ok', b: 'yes' &#125;console.log(obj1, obj2); // &#123; a: 'ok' &#125; &#123; a: 'ok', b: 'yes' &#125; 深拷贝上面的例子由于对象都只有一层，所以使用浅拷贝，没什么问题，但万一对象变成了多层的时候，使用上述的方法都会出现问题，下面只举其中一个例子: 12345678910let obj1 = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;&#125;;let obj2 = &#123; ...obj1 &#125;;obj2.a.b.c = 2; // &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;console.log(obj1, obj2); // &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125; &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125; 那深拷贝又如何实现? 简单粗暴的方式: 递归 + 浅拷贝 1234567891011121314151617181920212223242526const isObject = source =&gt; &#123; return Object.prototype.toString.call(source) === \"[object Object]\";&#125;;const deepCopy = obj =&gt; &#123; let target = &#123;&#125;; for (let i of Object.keys(obj)) &#123; if (!isObject(obj[i])) &#123; target[i] = obj[i]; &#125; else &#123; target[i] = deepCopy(obj[i]); &#125; &#125; return target;&#125;;let obj1 = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;&#125;;let obj2 = deepCopy(obj1);obj2.a.b.c = 2; // &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;console.log(obj1, obj2); // &#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125; &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125; 这种方法会存在跟数组以及 ES6 相关 api 的问题，同时递归遇到很深的层次以及循环引用也会出现问题，由于只是简单实现就不考虑了。 JSON API 法 这种方法比较简单，只需要一行代码即可: 12345678910let obj1 = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;&#125;;let obj2 = JSON.parse(JSON.stringify(obj1));obj2.a.b.c = 2; // &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;console.log(obj1, obj2); // &#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125; &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125; 这种方法看起来特别简单，但存在局限性: JSON.stringify 在序列化的时候，会忽略值为undefined、symbol的整个键值对，并且不能序列化函数以及不能解决循环引用的对象。 MessageChanel API 12345678910111213141516171819202122const deepCopy = obj =&gt; &#123; return new Promise(resolve =&gt; &#123; const &#123; port1, port2 &#125; = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); &#125;);&#125;;let obj1 = &#123; a: &#123; b: &#123; c: 1 &#125; &#125;&#125;;let obj2 = null;deepCopy(obj1).then(val =&gt; (obj2 = val));obj2.a.b.c = 2; // &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125;console.log(obj1, obj2); // &#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125; &#123; a: &#123; b: &#123; c: 2 &#125; &#125; &#125; 这种方法仅在所需拷贝对象含有内置类型并且不包含函数的情况下使用。 总结:上面三种方式都能实现深拷贝，但都存在问题，目前业界常用的解决方案是使用 lodash 的 cloneDeep api，在下一篇文章尝试阅读该 api 的源码。 参考 MDN - JavaScript 数据类型和数据结构《JavaScript 高级程序设计 第 3 版》 第四章InterviewMap","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cirnobreak.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://cirnobreak.github.io/tags/Javascript/"}]},{"title":"如何编写一个简易的模块打包工具","slug":"SimplePacking","date":"2019-02-25T16:00:00.000Z","updated":"2020-03-07T14:02:45.334Z","comments":true,"path":"2019/02/26/SimplePacking/","link":"","permalink":"https://cirnobreak.github.io/2019/02/26/SimplePacking/","excerpt":"","text":"在现代前端开发中，像 Webpack、Rollup、Parcel 等打包工具已经成为不可缺少的一部分，其中 Webpack 是最常用的。为了了解 Webpack 的工作原理，再加上自己曾经在面试过程中也被问过如何实现简易的模块打包工具却不知道如何回答，于是打算开始学习这一部分的内容。 在观看之后，初步了解到 webpack 的打包是先从入口文件开始，以import作为线索去寻找模块，实现一个简易的打包工具也是如此。 准备工作在实现简易的打包工具之前，先通过命令来安装我们所需要的模块: 1yarn add babylon babel-traverse babel-core 其中，babylon用于把(入口)文件的代码转换成 AST(抽象语法树),使用babel-travse遍历 AST 的 import 声明(ImportDeclaration)部分来寻找模块依赖关系，把遍历到的内容(模块名)存放到模块依赖数组里面,使用babel-core的transformFromAst模块把(入口)文件的代码(import 不能被浏览器识别)生成的 AST 代码转换成浏览器所能识别的代码(ES6 转 ES5)。 整个项目的结构如下: 12345|-- example |-- entry.js |-- message.js |-- name.js|-- minipack.js 其中 example 为我们要打包的的示例，minipack.js 是我们下面要编写的简易的模块打包工具。 示例的代码如下: entry.js 123import message from \"./message.js\";console.log(message); message.js 123import &#123; name &#125; from \"./name.js\";export default `hello $&#123;name&#125;!`; name.js 1export const name = \"hihihhi\"; 准备工作做好了，下面开始编写打包工具的代码。 第一部分 - createAsset(解析依赖关系)createAsset 主要用于解析文件内模块依赖信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const fs = require(\"fs\");const path = require(\"path\");const babylon = require(\"babylon\");const traverse = require(\"babel-traverse\").default;const &#123; transformFromAst &#125; = require(\"babel-core\");// 模块唯一标识符let ID = 0;function createAsset(filename) &#123; // 以字符串的形式去读取文件的内容 const content = fs.readFileSync(filename, \"utf-8\"); // 把文件内容解析为AST const ast = babylon.parse(content, &#123; sourceType: \"module\" &#125;); // 模块依赖数组(存放模块相对路径) const dependencies = []; // 遍历AST里面的import声明 traverse(ast, &#123; ImportDeclartion: (&#123; node &#125;) =&gt; &#123; // 把值存放到依赖关系数组里面 dependencies.push(node.source.value); &#125; &#125;); // 分配模块唯一标识符，为ID的递增 const id = ID++; // 利用`babel-preset-env`的规则转换AST的代码(es6转es5) const &#123; code &#125; = transformFromAst(ast, null, &#123; presets: [\"env\"] &#125;); // 当前文件的所有信息 return &#123; id, filename, dependencies, code &#125;;&#125; 我们把入口文件代码放到AST Explorer这个网站上，我们可以很清楚的看到，import message from &#39;./message.js&#39;;这一行代码在ImportDeclaration的部分，是我们遍历的线索，也是使用babel-traverse时的关键。 我们来分析下createAsset做了什么: 通过传入文件路径，使用fs来读取文件内容。 通过babylon解析获取到的内容(代码)并解析成AST。 通过babel-traverse遍历AST，去寻找模块的依赖关系，也就是是否还引入了别的模块，把找到的模块依赖关系存放到dependencies数组。 使用babel-core的transformFromAst模块，把AST的代码转换成ES5。 最后返回一个对象，包含当前模块的标识符(id)、当前文件的路径、当前文件的依赖关系以及当前文件转换后的代码。 最后，运行下代码后输出以下结果: 第二部分 - createGraph(生成依赖图)这一部分是调用 createAsset 来解析入口文件，从入口文件开始分析模块依赖关系来了解应用程序之间的每一个模块以及他们是如何依赖的，形成依赖图。 12345678910111213141516171819202122232425262728293031323334353637// entry为入口文件的相对路径function createGraph(entry) &#123; // 解析整个入口文件，获取相关信息 const mainAsset = createAsset(entry); // 使用队列queue来存放每个asset的依赖关系,初始值是只有mainAsset相关信息的数组 const queue = [mainAsset]; // 遍历队列 // 最初队列只有mainAsset，但在遍历过程中，会有新的asset进入队列 // 循环直队列尾为止 for (const asset of queue) &#123; // 存放模块依赖关系 asset.mapping = &#123;&#125;; // 获取这个模块所在目录的路径 const dirname = path.dirname(asset.filename); // 遍历模块依赖关系列表(相对路径) asset.dependencies.forEach(relativePath =&gt; &#123; // 当前模块所在文件的绝对路径 const absolutePath = path.join(dirname, relative); // 获取当前模块的依赖关系 const child = createAsset(absolutePath); // 把依赖关系存放到mapping,对应关系为 相对路径 -&gt; 模块id asset.mapping[relativePath] = child.id; // 把child存放到队列 queue.push(child); &#125;); &#125; // 返回依赖关系图 return queue;&#125; 下面分析下 createGraph 做了什么: 获取入口文件的信息，然后创建一个数组 queue，先存放入口文件的信息。 遍历数组，一开始数组只有入口文件的信息，但在遍历的过程中，假如入口文件含有其他依赖的文件，会在遍历过程中push到queue里面，直到文件最后没有依赖，遍历到 queue 队尾时停止遍历。 在遍历过程中，我们会把依赖关系存放到 mapping 里面，对应关系为: 模块的相对路径 -&gt; 模块 id。 获取当前模块对应文件的依赖关系，并存放到队列。 返回队列。 最后运行代码，结果如下: 最后一部分 - bundle这一部分是把上面 createGraph 生成的信息做整合，打包代码。 123456789101112131415161718192021222324252627282930313233343536373839404142// 接收`createGraph(entry)`生成的信息，打包function bundle(graph) &#123; let modules = \"\"; // 遍历graph的信息，生成传给IIFE的代码 // 结构: \"&#123;0: function (require, module, exports) &#123;xxx&#125;, './xxx': 0&#125;, ...\" graph.forEach(mod =&gt; &#123; modules += `$&#123;mod.id&#125;: [ function (require, module, exports) &#123; $&#123;mod.code&#125; &#125;, $&#123;JSON.stringify(mod.mapping)&#125; ]`; &#125;); // 把commonjs代码转成浏览器能运行的代码 // require 函数先从0(入口)开始 // 处理完之后返回result(可以运行的代码) const result = ` (function (modules) &#123; function require (id) &#123; const [fn, mapping] = modules[id]; function localRequire(name) &#123; return require(mapping[name]); &#125; const module = &#123; exports: &#123;&#125; &#125;; fn(localRequire, module, module.exports); return module.exports; &#125; require(0); &#125;)(&#123;$&#123;modules&#125;&#125;) `; return result;&#125; 运行结果如下: 最后我们把这段代码，拷贝到浏览器控制台，结果如下: 我们发现，他成功的输出了我们想要的结果，大功告成。 参考 Webpack founder Tobias Koppers demos bundling live by hand &gt; BUILD YOUR OWN WEBPACK by Ronen Amiel &gt; minipack《前端面试之道》 - 实现小型打包工具","categories":[{"name":"webpack","slug":"webpack","permalink":"https://cirnobreak.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://cirnobreak.github.io/tags/webpack/"}]},{"title":"[译]在docker上开发一个简单的React(next.js)应用","slug":"dockernext","date":"2019-01-25T16:00:00.000Z","updated":"2020-03-07T14:02:23.217Z","comments":true,"path":"2019/01/26/dockernext/","link":"","permalink":"https://cirnobreak.github.io/2019/01/26/dockernext/","excerpt":"","text":"原文链接: A simple React(Next.js) app development on Docker原文作者: Hyeokwoo Alex Kwon 当你要部署一个微服务架构的应用时，在把它部署到生产环境服务器上之前你不能测试它里面所有的服务。通常这会花费很长的时间才能得到反馈。Docker 有助于加快这一过程，因为它使本地小型独立服务更容易链接在一起。 在这篇文章，我们会通过如何去设置并且使用 docker 来进行 react.js 的应用开发。我们会构建一个简单的 next.js 应用并且把它当做成一个 docker 镜像，以便运行在本机的生产环境上运行一个容器。 1. 构建一个简单的 next.js 应用首先，我们开始编写一个简单的服务端渲染(ssr)的 react 应用，并通过设置把它做成一个很小的 docker 镜像。我们使用 next.js 库是因为它允许我们去构建一个支持 SSR 的 react 应用。 docker 镜像是一个创建和运行 docker 容器，或者构建其他镜像的文件。docker 镜像包含一个应用和它的执行代码，用于构建和运行。参考 让我们用下面的命令在本地新建一个项目: 123mkdir docker-nextjscd docker-nextjsyarn init 在这个刚建的 node.js 项目下安装 next.js: 1yarn add next react react-dom 我们应该在package.json里面添加 scripts 来更方便地管理应用: 12345\"script\": &#123; \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start\"&#125; 然后我们来设置最简单的 next.js 路由。首先在主路由上新建一个简单的 hello world 页面。我们可以在项目根目录下新建pages/文件夹，并在里面新建index.js来实现。它会变成一个路由并且在主页面上渲染。 新建pages/index.js后在编写如下组件: 12345678910// pages/index.jsimport React from \"react\";class Index extends React.Component &#123; render() &#123; return &lt;div&gt;Hello World&lt;/div&gt;; &#125;&#125;export default Index; 现在我们可以在本地运行yarn dev命令来启动这个应用。你将可以通过localhost:3000来访问应用。 2. 编写 Dockerfile 来构建 docker 镜像到目前为止，我们已经构建了一个最小的 next.js hellow world 应用，现在我们来让它变成一个 docker 镜像。 docker 镜像可以在项目里面用单个文件来构建。Dockerfile，在定义上，”Dockerfile 是一个包含所有你通常需要手动执行的,用于构建 docker 镜像的文本文档”。 因此，主要是通过编写命令来构建和运行应用，您可以构建一个 docker 镜像。当你构建 docker 镜像的时候，docker 系统会读取包含所有命令列表并逐行执行以构建镜像的 Dockerfile。 好的，下面开始编写 Dockerfile。我们在项目里面新建一个叫Dockerfile的文件，并且在里面编写以下的代码: 1234567891011121314151617FROM node:10# 设置工作路径。所有的路径都会关联WORKDIRWORKDIR /usr/src/app# 安装依赖COPY package*.json ./RUN npm install# 拷贝源文件COPY . .# 构建应用RUN npm run build# 运行应用CMD [ \"npm\", \"start\" ] 这些代码包含用于构建和运行应用的命令集。第一行的FROM node:10,镜像会从 nodejs 官方 docker 镜像获取，因此应用可以在 nodejs 环境中运行。 下一条命令是用WORKDIR来把应用的工作路径设置成/usr/src/app。因此，当在镜像上运行容器的时候，所有拷贝的和构建好的文件都会在这个地方。 然后，我们添加npm install命令来安装依赖，并且使用COPY . .命令来拷贝源文件到 docker。我们还应该使用npm run build来把应用打包成生产版本和用npm start来运行应用。 好的!我们已经准备好用Dockerfile去构建 docker 镜像了。在终端上，定位到你的项目目录，运行以下命令: 1docker build -t &lt;你的docker用户名&gt;/docker-nextjs 使用 build 命令，docker 系统会通过Dockerfile上的命令来创建一个新的镜像。-t用于标记你的镜像，使得你更容易地在镜像列表里面找到你的镜像。你可以使用docker image命令来检查 docker 镜像。 3.在镜像上运行容器要使用 docker 实际运行应用，应该基于镜像运行 docker 容器。 容器是 docker 镜像实例化的运行时。到目前为止，我们可以使用构建好的 docker 镜像来创建容器。查看更多 由于我们拥有自己的 docker 镜像，我们可以用以下命令创建并且运行 docker 容器: 1docker run -d -p 3333:3000 &lt;你的docker用户名&gt;/docker-nextjs:latest 这行命令会用镜像&lt;你的docker用户名&gt;/docker-nextjs:latest去创建一个容器，并且把端口号绑定到3333:3000。此处的绑定意味着在 docker 里面应用是在3000端口运行，并且可以通过localhost:3000来访问(在本机是localhost:3333)。 总结通过阅读这篇文章，你能够掌握用最小最简单的方式来用 docker 部署 react 应用。这个例子只用 docker 部署了简单应用，但但至少您可以使用 docker 更快速地测试生产环境。希望你的生活过得更轻松愉快!🐳","categories":[{"name":"Docker","slug":"Docker","permalink":"https://cirnobreak.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://cirnobreak.github.io/tags/Docker/"}]},{"title":"从B站弹幕列表加载来了解DOM观察者-MutationObserver","slug":"MutationObserver","date":"2019-01-19T16:00:00.000Z","updated":"2020-03-07T14:02:39.073Z","comments":true,"path":"2019/01/20/MutationObserver/","link":"","permalink":"https://cirnobreak.github.io/2019/01/20/MutationObserver/","excerpt":"","text":"最近在用哔哩哔哩新版播放器的时候感觉十分别扭，侧边有广告，弹幕列表，由于习惯了旧版的默认展开个人不太习惯新版的，就开始打算写一个隐藏侧边广告+默认展开弹幕列表的小脚本，但在编写过程中并不顺利。因为 B 站他们使用的是 SSR 做首屏渲染，首次加载的是骨架屏，服务端渲染的弹幕列表只是一个占位的 div，并没有任何内容，随着后续的客户端渲染才慢慢加载 DOM 元素，但是这到底要怎么做才能去监听它 DOM 变化到渲染出弹幕列表 div 的时候呢？随后我习惯性地使用了 google 去搜索相关的方案，然后找到了一个监听 DOM 树更改的 API - MutationObserver。 MutationObserver 这个 API 是用来监听 DOM 变动的，DOM 发生的任何变动，比如结点的增减、属性的变动、文本内容的变动都可以从这个 API 上得到通知。它跟事件很接近，但是它跟事件有一个本质的不同点是:事件是同步触发的，即 DOM 变动立马触发相应事件，而 MutationObserver 是异步触发的，DOM 变动不会立马触发，而要等到所有 DOM 操作结束后才触发，这样的设计可以应付 DOM 频繁的变动。 MutationObserver API 的特点: 异步触发，等所有 DOM 操作结束后才触发。 把 DOM 变动记录封装成一个数组处理，而不是一条条个别处理 DOM 变动。 它可以观察 DOM 的所有类型的变动，也可以指定只观察某一类变动。 下面用 MDN 文档下 MutationObserver 的示例代码来展示一下这个 API 的实际效果，首先我们尝试监听哔哩哔哩新版播放器的 div.danmaku-wrap ，暂时先移除observer.disconnect()方法，然后在 tampermonkey 下添加脚本，代码如下: 123456789101112131415161718192021222324252627(function() &#123; \"use strict\"; // 被观察的目标节点 const targetNode = document.querySelector(\".danmaku-wrap\"); // observer选项 const config = &#123; attributes: true, childList: true, subtree: true &#125;; // 目标dom发生变动时执行的回调函数 const callback = function(mutationsList) &#123; for (let mutation of mutationsList) &#123; if (mutation.type == \"childList\") &#123; console.log(\"A child node has been added or removed.\"); &#125; else if (mutation.type == \"attributes\") &#123; console.log( \"The \" + mutation.attributeName + \" attribute was modified.\" ); &#125; &#125; &#125;; // 实例化观察者 const observer = new MutationObserver(callback); // 开始观察 observer.observe(targetNode, config);&#125;)(); 此时，随意在 b 站打开一个视频，并确保播放器切换到新版的情况下，用cmd/ctrl + shift + j 打开控制台，等待div.damaku-wrap渲染后会看到以下输出: 由于以上代码设置了监听元素 style 跟 DOM 树元素增删变化，所以会看到关于两者变化的相关输出动作，这些动作都存放在 mutationList 数组里。 但是，又到底怎么样才知道弹幕列表里面的内容 div 被渲染呢？ 接下来我们修改下代码，只监听元素节点变动： 123456789101112131415161718192021(function() &#123; \"use strict\"; // 被观察的目标节点 const targetNode = document.querySelector(\".danmaku-wrap\"); // observer选项 const config = &#123; childList: true, subtree: true &#125;; // 目标dom发生变动时执行的回调函数 const callback = function(mutationsList) &#123; for (let mutation of mutationsList) &#123; console.log(\"mutation\", mutation); &#125; &#125;; // 实例化观察者 const observer = new MutationObserver(callback); // 开始观察 observer.observe(targetNode, config);&#125;)(); 继续刷新页面，等待输出。输出结果如下: 此时我们可以看到每次 DOM 结点变动的详细信息，但是我们又该怎么知道到底什么时候才渲染出弹幕列表(-_-)ゞ？ 此时我们使用了Chrome Dev Tools 的 Inspector 找到了弹幕列表 body 的相应元素div.bui-collapse-body。 好了，现在找到了主要目标，但是接下来又该怎么做？ 我们再次修改代码，此时我们主要是看在这个变动列表里面，何时才会渲染出div.player-auxiliary。 12345678910111213141516171819202122(function() &#123; \"use strict\"; // 被观察的目标节点 const targetNode = document.querySelector(\".danmaku-wrap\"); // observer选项 const config = &#123; childList: true, subtree: true &#125;; // 实例化观察者 const callback = function(mutationsList) &#123; for (let mutation of mutationsList) &#123; console.log(\"mutation\", mutation); console.log(document.querySelector(\".player-auxiliary\")); &#125; &#125;; // 实例化观察者 const observer = new MutationObserver(callback); // 开始观察 observer.observe(targetNode, config);&#125;)(); 再次刷新，我们从控制台可以看出来，在第二次 dom 变动的时候渲染出了div.player-auxiliary。 但并不是永远是第二次，在我调试的时候，有视频选集的页面可能并不会是第二次，所以我们继续寻找线索。 展开第二次输出的信息，我们把player-auxiliary字符串以及它是class作为线索，轻易的找到了它所在的位置： 它就在mutation.target.classList里，此时使用 value 属性做判断条件比较简单，再次修改下代码： 1234567891011121314151617181920212223242526(function() &#123; \"use strict\"; // 被观察的目标节点 const targetNode = document.querySelector(\".danmaku-wrap\"); // observer选项 const config = &#123; childList: true, subtree: true &#125;; // Callback function to execute when mutations are observed const callback = function(mutationsList) &#123; for (let mutation of mutationsList) &#123; console.log(\"mutation\", mutation); console.log( \"find dom\", mutation.target.classList.value.includes(\"player-auxiliary\") ); console.log(document.querySelector(\".player-auxiliary\")); &#125; &#125;; // 实例化观察者 const observer = new MutationObserver(callback); // 开始观察 observer.observe(targetNode, config);&#125;)(); 我们再回来看看 console ，发现自从找到它之后，每次都会输出 true。 该如何避免频繁的判断? 此时借助 flag，当 flag 为 true 后就不再输出 found。来让它找到之后就不再执行。 123456789101112131415161718192021222324252627282930313233(function() &#123; \"use strict\"; // 被观察的目标节点 const targetNode = document.querySelector(\".danmaku-wrap\"); // observer选项 const config = &#123; childList: true, subtree: true &#125;; // 目标dom发生变动时执行的回调函数 const callback = function(mutationsList) &#123; let flag; for (let mutation of mutationsList) &#123; console.log(\"mutation\", mutation); if ( !flag &amp;&amp; mutation.target.classList.value.includes(\"player-auxiliary\") ) &#123; console.log( \"find dom\", mutation.target.classList.value.includes(\"player-auxiliary\") ); flag = true; &#125; console.log(document.querySelector(\".player-auxiliary\")); &#125; &#125;; // 实例化观察者 const observer = new MutationObserver(callback); // 开始观察 observer.observe(targetNode, config);&#125;)(); 从输出结果可以看出 found 现在找到之后就不再执行了。 最后，实现弹幕列表自动展开这功能就很简单了，只需要在 if 判断里面执行 弹幕列表 header 的 click 事件即可。代码整理一下，最终的函数如下。 12345678910111213141516171819202122232425262728293031323334353637(function() &#123; \"use strict\"; // 简单地抽离一下querySelector函数 const selector = selector =&gt; document.querySelector(selector); // 被观察的目标节点 const targetNode = selector(\".danmaku-wrap\"); // 目标dom发生变动时执行的回调函数 const config = &#123; childList: true, subtree: true &#125;; // 判断是否找到弹幕列表(是否加载出来) const findDom = target =&gt; &#123; return target.classList.value.includes(\"player-auxiliary\"); &#125;; // 实例化观察者 const callback = function(mutationsList) &#123; let flag; for (let mutation of mutationsList) &#123; const target = mutation.target; if (!flag &amp;&amp; findDom(target)) &#123; // 找到后触发弹幕列表标题点击事件 selector(\".bui-collapse-header\").click(); flag = true; // 停止观察 observer.disconnect(); &#125; &#125; &#125;; // 实例化观察者 const observer = new MutationObserver(callback); // 开始观察 observer.observe(targetNode, config);&#125;)(); 参考: MDN 文档 MutationObserver API &gt; Javascript 标准参考教程 - Mutation Observer API","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://cirnobreak.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://cirnobreak.github.io/tags/Javascript/"}]},{"title":"windows系统安装Android Studio和配置Flutter","slug":"FlutterWin","date":"2019-01-09T16:00:00.000Z","updated":"2020-03-07T14:02:25.835Z","comments":true,"path":"2019/01/10/FlutterWin/","link":"","permalink":"https://cirnobreak.github.io/2019/01/10/FlutterWin/","excerpt":"","text":"Flutter 是谷歌开源的，一个全新的移动 UI 框架，在 2018 年 12 月初发布了 1.0 正式版本，由于本人是做前端开发的，对原生开发不太了解，想从 Flutter 开始入手，但是，在环境配置方面并不是那么的顺利，期间也踩了不少坑。由于环境是 Flutter1.0 发布不久后才部署好的，现在只能考记忆来回顾环境配置的过程。 需要下载的工具 Android Studio(需要科学上网): https://developer.android.com/studio/ Flutter SDK 1.0 稳定版 https://storage.googleapis.com/flutter_infra/releases/stable/windows/flutter_windows_v1.0.0-stable.zip 设置 Flutter SDK 环境变量把下载好的Flutter SDK放到任意你觉得方便的位置，解压。然后右键 此电脑，选择属性，依次点击 高级系统设置 -&gt; 环境变量，双击 xxx 的用户变量 下面的path，点新建，然后输入你 Flutter SDK 所在的目录，比如我的 Flutter SDK 是放在 C 盘下的 src，则要输入 C:\\src\\flutter\\bin，其他位置同理，记得一定是定位到bin下面。 设置 Flutter SDK 镜像在终端(cmd/powershell)下面输入以下命令: 12set PUB_HOSTED_URL=https://pub.flutter-io.cnset FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 即可,详细参考https://flutter.io/community/china 运行 Flutter Doctor打开一个新的 cmd 或 PowerShell，输入 flutter doctor 来运行，flutter doctor 是拿来检测你缺少哪些依赖，一般此时会显示你缺少(虚拟/真实)设备，那此时就需要 Android Studio 的模拟器或者你自己的手机(安卓机)。 安装 Android Studio根据提示直接安装到完成，然后打开 Android Studio，如果是第一次安装，可能会提示你缺少 SDK，这是会让你选择下载 SDK 的目录并开始下载(Android SDK 的谷歌镜像速度还是蛮快的，如果觉得慢可以尝试使用国内 Android Studio SDK 镜像),目录尽量不要选择 C 盘(由于 SDK 巨大，之前选择 SDK 装在 C 盘，装了几个之后被占了几十 G)，可以选择你自己喜欢的地方。 当 SDK 下载完之后，可以进入 Android Studio 的欢迎界面，点击右下角的 configure -&gt; SDK Manager 可以进入 SDK 管理界面。进入界面之后可以看到你 SDK 的安装情况，以及该 SDK 的详情(需要点击右下方的 Show Package Detail)。 假如需要安装新的 SDK，只需要在对应的 SDK 打上勾后点 OK 即可。 配置 Android SDK 环境变量在上述的配置环境变量界面，同样是在 xxx 的用户变量下面，点击 新建，新建一个名为ANDROID_HOME的环境变量，然后路径是你 Android SDK 的路径(可通过浏览文件选择)，比如: F:\\Android\\sdk。 新建一个 Flutter 项目使用 Android Studio 创建在 Android Studio 的 欢迎界面 ，也就是一开始的界面，点击 Start a new Flutter project后，进入 Create New Flutter Project的界面后有三个选项，点击第一个Flutter Application后点击 next 此时会让你输入项目名称、项目描述，还有 Flutter SDK 的路径和项目位置的选择，自定义结束后点击 next，后面是包名的配置，定义结束后按 Finish 完成项目创建。 使用 Visual Studio Code 创建在打开 Visual Studio Code 的情况下，按下组合键 ctrl + shift + x，或者直接点开左边活动栏第四个按钮(拓展)，在应用商店搜索并安装Dart和Flutter插件，插件安装完成后重启 Visual Studio Code。此时在 Visual Studio Code 按下组合键 ctrl + shift + p，输入 Flutter，点击Flutter:New Project，他会让你输入项目名字，比如可以输入 my_app 并按下回车来新建一个叫 my_app 的项目，此时会让你选择该项目的路径，选择完成确定后等待即可。 运行 Android Studio 的虚拟机(AVD)在 Android Studio 打开任意项目，打开后在右上角找到AVD Manager， 点击进入，此时可以点击Create Virtual Device来创建虚拟机，根据自己的需求来选择对应型号的虚拟机,选择后点击 next，会进入System Image(系统镜像)选择界面，(由于这里我之前试过被墙，一直转圈无法加载，这种情况出现时需要科学上网),选择对应的安卓系统镜像后(假如没有需要下载)，点 next，编辑好参数后点 finish 即可。虚拟机安装完成之后，AVD Manager里面会成功显示你安装好的虚拟机，此时点击Actions下的绿色按钮即可运行虚拟机。 第一次加载需要漫长的加载，请耐心等待。 运行 Flutter 项目Flutter 项目主要运行的是 lib 文件夹下的 main.dart，同时确保真机/模拟器打开。 Visual Studio Code 运行首先运行虚拟机或者连接真机，然后在 Visual Studio Code 下点开当前项目 lib 文件夹下的 main.dart，按下 F5 即可。 Android Studio 运行首先运行虚拟机或者连接真机，然后点击 Android Studio 上方的绿色播放按钮即可。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://cirnobreak.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://cirnobreak.github.io/tags/Flutter/"}]},{"title":"从Mixins到hooks,浅谈React组件逻辑复用","slug":"组件复用","date":"2018-12-30T16:00:00.000Z","updated":"2020-03-07T14:02:16.352Z","comments":true,"path":"2018/12/31/组件复用/","link":"","permalink":"https://cirnobreak.github.io/2018/12/31/%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/","excerpt":"","text":"在开发项目的过程中，你可能会发现，在写组件的时候，会出现一种多个组件共用一种逻辑的情况，然而每个组件都重复去实现这同一种逻辑是一件重复性的工作，违背了 DRY(Don’t Repeat Yourself)的原则。那该如何解决这种情况? 在 Vue.js 中，可以使用 Vue.js 自带的混入(mixins)来解决组件逻辑复用的问题，同样地，React.js 的也自带 Mixins 这种解决方案，但这种方案仅支持 React.createClass 创建组件的形式而不支持 ES6 class 创建的组件(React 官方文档上的说明: ES6 launched without any mixin support. Therefore, there is no support for mixins when you use React with ES6 classes.)。正因如此，后来开始出现了高阶组件 HOC(high order component)、Render Props 以及 react hooks 等解决方案。 MixinsReact 的 mixins 跟 Vue 的 mixins 很相似，都是把公共的逻辑抽离到混入对象里面，然后在组件使用 mixins。下面使用 vue.js 跟 react.js 的 mixins 来实现获取鼠标位置的例子。 Vue.js mixins12345&lt;template&gt; &lt;div @mousemove=\"handleMouseMove\"&gt; &lt;h1&gt;Current mouse position: x : &#123;&#123; x &#125;&#125; y: &#123;&#123; y &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718const mixin = &#123; data() &#123; return &#123; x: 0, y: 0 &#125;; &#125;, method: &#123; handleMouseMove(e) &#123; this.x = e.clientX; this.y = e.clientY; &#125; &#125;&#125;;new Vue(&#123; mixins: [mixin]&#125;); React.js Mixins1234567891011121314151617181920212223242526272829const mixin = &#123; getInitialState() &#123; return &#123; x: 0, y: 0 &#125;; &#125;, handleMouseMove(e) &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;); &#125;&#125;;const App = React.createClass(&#123; mixins: [mixin], render() &#123; const &#123; x, y &#125; = this.state; return ( &lt;div className=\"App\" onMouseMove=&#123;this.handleMouseMove.bind(this)&#125;&gt; Current mouse position: x: &#123;x&#125; y: &#123;y&#125; &lt;/div&gt; ); &#125;&#125;);const rootElement = document.getElementById(\"root\");ReactDOM.render(&lt;App /&gt;, rootElement); 为何不使用 Mixins?Mixins 看起来十分容易理解，但为什么不推荐使用 Mixins 来复用代码，同时 ES6 class 声明的组件也不支持？ 一、 引入隐式依赖(Mixins introduce implicit dependencies) JS 是动态语言，很难执行或者记住复杂的依赖的关系。有时候，一个组件会依赖 mixins 里面的特定的方法，比如: getClassName()，有时用另外的方法，在组件上的 mixins 会比如renderHeader()的方法。 Mixins 破坏了常见的安全前提，你可以重命名一个状态键或者一个方法，通过在组建中搜索就行。但你可能写一个状态组件，然后你的同事会添加一个读取这个状态(state)的 mixins，几个月后再想修改，把状态提到父组件中便于兄弟间通信的时候，你是否还记得是更新 mixins 而不是去读取一个 prop。 隐式依赖对团队新成员继续维护更新一个代码库是非常困难的。 二、 Mixins 造成命名冲突 不能保证两个单独的 Mixins 可以一起使用。比如 FluxListenerMixin 定义了 handleChange()，WindowSizeMixin 也定义了 handleChange()，你不能一起使用它们，你也不能在自己的组件使用这个名称定义方法。 三、 Mixins 导致滚雪球式的复杂性 尽管 Mixins 像上面的例子一样看起来很简单，但是，随着时间推移，它会变得越来越复杂，特别是新需求来了的时候。 高阶组件 HOC在 Mixins 之后，为了更好地实现逻辑复用，在 React 社区里出现了高阶组件这种形式。在 React 官方文档是这样描述的: 高阶组件(HOC)是 react 中对逻辑进行复用的高级技术，并不是 React API。它只是一种模式，这种模式是由 react 自身的组合性质必然产生的(A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React’s compositional nature.)。 高阶组件本质是一个函数，它接收一个组件作为参数，并返回一个新的组件。比如: 1const EnhancedComponent = highOrderComponent(WrappedComponenet); 常用的 redux 中的connect方法也是高阶组件的实现。 下面用高阶组件来实现下 获取当前鼠标位置 的逻辑: 12345678910111213141516171819202122232425262728293031const withMouseMove = Component =&gt; &#123; return class extends Component &#123; state = &#123; x: 0, y: 0 &#125;; handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;); &#125;; render() &#123; return ( &lt;div onMouseMove=&#123;e =&gt; this.handleMouseMove(e)&#125;&gt; &lt;Component &#123;...this.props&#125; mouse=&#123;this.state&#125; /&gt; &lt;/div&gt; ); &#125; &#125;;&#125;;const App = (&#123; mouse: &#123; x, y &#125; &#125;) =&gt; ( &lt;div&gt; Current mouse position is: x: &#123;x&#125; y: &#123;y&#125; &lt;/div&gt;);const appWithMouse = withMouseMove(App); 使用 ES7 装饰器(decorator)实现: 12345678910111213141516171819202122232425262728293031323334353637const withMouseMove = Component =&gt; &#123; return class extends React.Component &#123; state = &#123; x: 0, y: 0 &#125;; handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;); &#125;; render() &#123; return ( &lt;div onMouseMove=&#123;e =&gt; this.handleMouseMove(e)&#125;&gt; &lt;Component &#123;...this.props&#125; mouse=&#123;this.state&#125; /&gt; &lt;/div&gt; ); &#125; &#125;;&#125;;@withMouseMoveclass App extends React.Component &#123; render() &#123; const &#123; mouse: &#123; x, y &#125; &#125; = this.props; return ( &lt;div&gt; Current mouse position is: x: &#123;x&#125; y: &#123;y&#125; &lt;/div&gt; ); &#125;&#125; 高阶组件高级用法一、 一个高阶组件中传入多个组件作为参数。比如实现一个根据是否登录来显示导航栏未登录跟登录的两种状态的组件，分别传入 ComponentForLogin(登录时)和 ComponentForLogout 两个组件作为参数。 123456789101112const withLoginAndLogout = (ComponentForLogin, ComponentForLogout) =&gt; &#123; const NewComponent = props =&gt; &#123; if (getUserId()) &#123; return &lt;ComponentForLogin &#123;...props&#125; /&gt;; &#125; else &#123; return &lt;ComponentForLogout &#123;...props&#125; /&gt;; &#125; &#125;; return NewComponent;&#125;;const TopButtons = withLoginAndLogout(LogoutButton, LoginButton); 二、 高阶组件的链式调用 假如有三个高阶组件 withOne、withTwo、withThree 来给包装一个高阶组件 X，有几种方式: 直接包装。 1234const X1 = withOne(X);const X2 = withTwo(X1);const X3 = withThree(X2);const SuperX = X3; // 最终的具备三个高阶组件能力的高阶组件SuperX 也可以写成: 1const SuperX = withThree(withTwo(withOne(x))); 使用 compose。 由于高阶组件本身是一个纯函数，也就是说，可以使用函数式编程里的 compose 来包装 X，即: 1234567891011121314function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg; &#125; if (funcs.length === 1) &#123; return funcs[0]; &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));&#125;const hoc = compose(withThree, withTwo, withOne);const SuperX = hoc(X); 使用装饰器(decorator)。 123456@withThree@withTwo@withOneclass X extends React.Component &#123; /*...*/&#125; 使用 displayName 便于调试由于高阶组件在React dev tools表现的跟普通组件一样，为了方便调试必须要给一个displayName。最常用的技术就是将包裹组件的名字包装在显示名字中。所以，如果你的高阶组件名字是 withSubscription，且包裹组件的显示名字是 CommentList，那么就是用 WithSubscription(CommentList)这样的displayName: 12345678910111213function withSubscription(WrappedComponent) &#123; class WithSubscription extends React.Component &#123; /* ... */ &#125; WithSubscription.displayName = `WithSubscription($&#123;getDisplayName( WrappedComponent )&#125;)`; return WithSubscription;&#125;function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || \"Component\";&#125; 高阶组件的注意事项 不要在 render 函数中使用高阶组件。 React 使用的 diff 算法(Reconciliation，也叫协调)使用组件标识确定是否更新现有的子对象树或丢掉现有的子树并重新挂载。如果 render 函数返回的组件和之前 render 函数返回的组件是相同的，React 就递归地比较新子对象树和旧的子对象树的差异，并更新旧的子对象树。如果它们不相等，就会完全卸载掉旧的子对象树。 下面的代码会产生问题: 1234567render() &#123; // 每一次render函数调用都会创建一个新的EnhancedComponent实例 // EnhancedComponent1 !== EnhancedComponent2 const EnhancedComponent = enhance(MyComponent); // 每一次都会使子对象树完全被卸载或移除 return &lt;EnhancedComponent /&gt;;&#125; 在这里产生的不仅是性能问题，还有重新加载一个组件会引起原有组件所有状态和子组件的丢失。相反，在组件外定义 HOC 使新组建只出现一次的定义，在渲染过程中确保都是同一个组件。 必须将静态方法做拷贝 当使用高阶组件包装组件，原始组件被容器组件包裹，也就意味着新组件会丢失原始组件的所有静态方法。 123456789// 定义静态方法WrappedComponent.staticMethod = function() &#123; /*...*/&#125;;// 使用高阶组件const EnhancedComponent = enhance(WrappedComponent);// 增强型组件没有静态方法typeof EnhancedComponent.staticMethod === \"undefined\"; // true 解决这个问题的方法就是，将原始组件的所有静态方法全部拷贝给新组件: 12345678function enhance(WrappedComponent) &#123; class Enhance extends React.Component &#123; /*...*/ &#125; // 必须得知道要拷贝的方法 Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance;&#125; Ref 属性不能传递(React 16.3 版本提供了一个 React.forwardRef API 解决这个问题)。 Render PropsRender Props 是一种全新的组件复用方式，它指的是，在调用组件时，引入一个函数类型的 prop，这个 prop 定义了组件渲染的方式，换句话说，与其使用 Mixins，或者接收并返回一个组件的高阶组件，还不如在正常使用的情况下添加一个 prop 来实现在消费层面对不同渲染情况的自定义，最终实现代码复用。 使用 Render Props 来实现获取当前鼠标位置的逻辑: 123456789101112131415161718192021222324252627282930313233class Mouse extends React.Component &#123; state = &#123; x: 0, y: 0 &#125;; handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;); &#125;; render() &#123; return ( &lt;div onMouseMove=&#123;e =&gt; this.handleMouseMove(e)&#125;&gt; &#123;this.props.render(this.state)&#125; &lt;/div&gt; ); &#125;&#125;const App = () =&gt; ( &lt;div&gt; &lt;Mouse render=&#123;(&#123; x, y &#125;) =&gt; ( &lt;h1&gt; Current mouse position is: x: &#123;x&#125; y: &#123;y&#125; &lt;/h1&gt; )&#125; &gt;&lt;/Mouse&gt; &lt;/div&gt;); 不仅局限于 children(Function as Child Component)Function as Child Component 是指父组件接收一个函数来实现复用。这种方式 C 的特点在于父组件往往拥有一些内部状态或者需要做一些复杂且共享的计算，这些数据需要对外暴露来实现复用。 使用 Fuction as Child Component 来实现获取当前鼠标位置的逻辑: 123456789101112131415161718192021222324252627282930313233class Mouse extends React.Component &#123; state = &#123; x: 0, y: 0 &#125;; handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY &#125;); &#125;; render() &#123; return ( &lt;div onMouseMove=&#123;e =&gt; this.handleMouseMove(e)&#125;&gt; &#123;this.props.children(this.state)&#125; &lt;/div&gt; ); &#125;&#125;const App = () =&gt; ( &lt;div&gt; &lt;Mouse&gt; &#123;(&#123; x, y &#125;) =&gt; ( &lt;div&gt; Current mouse position is: x: &#123;x&#125; y: &#123;y&#125; &lt;/div&gt; )&#125; &lt;/Mouse&gt; &lt;/div&gt;); HooksHooks 是 React v16.7.0-alpha 引入的概念(截止 2018.12.31 React 的正式版为 16.7，暂时没有 Hooks)，以后正式发布 API 可能会变化。Hooks 的主要目的是让开发者摆脱 class 来实现组件。其中 useState 是实现在不编写 class 的情况下使用 state 的方法，而 useEffect 是在不编写 class 的情况下来替代 React 生命周期的一些副作用的方法。 使用简单的 Hooks 来实现获取鼠标位置的逻辑: 1234567891011121314151617181920212223242526function usePos(element) &#123; let [pos, setPos] = useState(&#123; x: 0, y: 0 &#125;); function handlePos(e) &#123; setPos(&#123; x: e.clientX, y: e.clientY &#125;); &#125; useEffect(() =&gt; &#123; element.current.addEventListener(\"mousemove\", handlePos); return () =&gt; &#123; element.current.removeEventListener(\"mousemove\", handlePos); &#125;; &#125;, []); return pos;&#125;function App() &#123; let ele = React.createRef(); const pos = usePos(textInput); return ( &lt;div ref=&#123;ele&#125;&gt; Current mouse position is: x: &#123;pos.x&#125; 7: &#123;pos.y&#125;&#125; &lt;/div&gt; );&#125; 参考 React.js 官方文档Mixins Considered Harmful掘金小册《React 实战：设计模式和最佳实践》《React 状态管理与同构实战》","categories":[{"name":"React","slug":"React","permalink":"https://cirnobreak.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://cirnobreak.github.io/tags/React/"}]},{"title":"vim学习之vimtutor笔记","slug":"vim学习之vimtutor笔记","date":"2018-11-26T16:00:00.000Z","updated":"2020-03-07T14:02:48.934Z","comments":true,"path":"2018/11/27/vim学习之vimtutor笔记/","link":"","permalink":"https://cirnobreak.github.io/2018/11/27/vim%E5%AD%A6%E4%B9%A0%E4%B9%8Bvimtutor%E7%AC%94%E8%AE%B0/","excerpt":"","text":"方向h(左移) j(下移) k(右移) l(右移)，也可以使用方向键。 进入跟退出进入: 输入 vim 文件名 &lt;回车&gt;。 退出: 保存并退出:输入 :wq! &lt;回车&gt;。 退出但不保存: 输入 :q! &lt;回车&gt;。 删除单个字符在正常模式下在光标所在位置按 x 可以删除光标所在位置单个字符。 插入/添加 光标前插入: 输入 i。 当前行最后插入: 输入 A。 在当前光标后插入: 输入 a。 计数指定动作比如: 输入 2w 光标往后移动两个单词。 输入 3e 光标往后移动到第三个单词的词尾。 输入 0 移动光标到行首。 删除相关命令(与 d 有关)基本操作许多改变文本的命令都由一个操作符和一个动作构成。使用删除操作符 d 的删除命令的格式如下: d motion 其中 d 是删除操作符，motion 是操作符的操作对象,比如: 删除从当前光标到下一个单词的起始处: 输入 dw。 删除光标到单词末尾，包括最后一个字符: 输入 de。 删除从当前光标到行末的所有字符: 输入 d$。 计数删除在删除操作符跟动作的组合中，在动作前加上一个数字可以删除更多: d number(数字) motion 比如输入 d2w 可以删除两个单词。 删除整行 输入 dd 可以删除当前行。 输入 2dd 可以删除两行。 撤销类命令 按下 u 可以恢复上一次操作。 按下 U 可以恢复光标所在行的初始状态。 按 CTRL+R 可以重做被撤销的命令，也就是撤销掉撤销命令。 置入类命令p 可以把最后一次删除(复制)的内容置入光标之后。 比如： 把一行移动到指定位置，可以先用 dd 命令删除该行，这样会将该行保存到 vim 的寄存器中，然后在光标所在行按下 p，会在光标后所在行的下一行粘贴置入。 替换类命令 在光标所在位置输入 r 和要替换的字符，就会把当前光标的内容替换成你要替换的内容。 在光标所在位置输入 R 可以连续替换字符。 更改类命令在光标所在位置，输入 cw 不仅可以删掉一个单词，同时可以进入插入模式。 更改类操作命令如下: c [number] motion 定位以及文件状态 按下 CTRL+G 可以显示光标所在行的位置以及文件状态信息。 输入 G 可以跳到文件的最后一行，输入 gg 可以跳到文件的第一行。 搜索类命令 输入 / 跟 要查找的字符串并按下 &lt;回车&gt;，比如: /errroor &lt;回车&gt;，可以在文件中找到你要找的字符串的位置。 此时按 n 可以往下查找，按下 N 可以往上查找。 如果是第一次逆向查找，使用? 代替 /即可。 ctrl+o 可以回退到之前查找的位置，ctrl+i 可以跳到较新位置。 配对括号查找%可以跳转到匹配当前行离光标最近的括号({[或者)}] 对应匹配的)}]或者({[的位置。 替换命令 在光标所在行，把头一个 old 替换成 new，输入 :s/old/new。 在光标所在行，把所有 old 替换成 new，输入 :s/old/new/g。 在光标所在处的两行内把所有的 old 替换成 new，输入 :#,#/old/new/g。 把文件内所有的 old 替换成 new，输入 :%s/old/new/gc。 执行外部命令输入:!紧跟着外部命令就会执行该外部命令，比如: 输入 :!ls 可以列举目录内容。 保存改动到文件输入 :w 文件名就可以把当前文件另存为该文件名的文件。 此时，如果想删除文件，可以使用如下命令: MS-DOC 下，输入 :!del 文件名。 Unix 下，输入 :!rm 文件名。 保存指定文本到文件按下 v 可以进入视图模式，然后移动光标选中文本会高亮，此时，输入 : 屏幕底部会出现:’&lt;,’&gt; 接着输入 w 文件名 会看到 :’&lt;,’&gt;w 文件名 ,按下&lt;回车&gt;后，将会把选中的文本保存当对应的文件下。 提取并合并文件当光标所在位置，输入 :r 文件名 会把对应文件名的内容提取到当前位置并置入。 打开类命令在光标处，输入 o 会在光标下方新建一行并进入插入模式，输入 O 则会往光标上方新建一行并进入插入模式。 复制粘贴文本输入 y 可以复制对应文本，输入 p 可以把复制的文本粘贴到光标后的位置。 设置类命令输入 :set xxx 可以设置 xxx 选项。 输入 :set ic,表示查找时忽略字母大小写(ignorecase) 输入 :set is,表示查找短语时显示部分匹配(incsearch) 输入 :set hls,表示高亮显示所有匹配短语(hlsearch) 在选项前输入 no 可以关闭选项，比如 :set noic 可以取消忽略大小写查找","categories":[{"name":"vim","slug":"vim","permalink":"https://cirnobreak.github.io/categories/vim/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vim","slug":"vim","permalink":"https://cirnobreak.github.io/tags/vim/"}]},{"title":"Vue同时使用@keyup.enter与@blur冲突","slug":"vue同时使用@keyup.enter与@blur冲突","date":"2018-08-29T16:00:00.000Z","updated":"2020-03-07T14:02:50.830Z","comments":true,"path":"2018/08/30/vue同时使用@keyup.enter与@blur冲突/","link":"","permalink":"https://cirnobreak.github.io/2018/08/30/vue%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8@keyup.enter%E4%B8%8E@blur%E5%86%B2%E7%AA%81/","excerpt":"","text":"vue 同时使用@keyup.enter 与@blur 冲突参考 https://www.jianshu.com/p/1d94bb8be9c3 最近在项目开发过程中，要实现一个可编辑标签。在提交修改的时候，需要做到按回车跟失去焦点都可以触发提交请求的操作，但是，在同一个标签上写@keyup.enter 与@blur 的时候，分别写单独的事件，会发现，按下回车的时候，不仅触发了@keyup.enter 的事件，还触发了@blur 的事件。 未修改前(冲突) 12345678910111213&lt;span class=\"editTag\" :id=\"tag.id\" :data-id=\"tag.foodId+'-'+tag.orderNo\" v-if=\"editable\" @click=\"preventSwitch\" @keydown.enter=\"editTagName($event, tag.name)\" slot=\"label\" @blur=\"editTagName($event, tag.name)\" contenteditable=\"true\"&gt; &#123;&#123;tag.name&#125;&#125;&lt;/span&gt; 修改后，回车时直接调用了 blur，避免冲突 12345678910111213&lt;span class=\"editTag\" :id=\"tag.id\" :data-id=\"tag.foodId+'-'+tag.orderNo\" v-if=\"editable\" @click=\"preventSwitch\" @keydown.enter=\"$event.target.blur\" slot=\"label\" @blur=\"editTagName($event, tag.name)\" contenteditable=\"true\"&gt; &#123;&#123;tag.name&#125;&#125;&lt;/span&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cirnobreak.github.io/tags/Vue/"},{"name":"踩坑","slug":"踩坑","permalink":"https://cirnobreak.github.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"node爬虫之尝试puppeteer","slug":"puppeteer","date":"2018-04-11T16:00:00.000Z","updated":"2020-03-07T14:02:42.421Z","comments":true,"path":"2018/04/12/puppeteer/","link":"","permalink":"https://cirnobreak.github.io/2018/04/12/puppeteer/","excerpt":"","text":"参考 puppeteer官方文档 &gt; [译] JavaScript 自动化爬虫入门指北,link爬虫利器 Puppeteer 实战,link 前段时间在看一本叫《Python编程快速上手》的书，里面有一节就介绍到了简单的爬虫，用request+BeautifulSoup实现一个简单的漫画网站爬虫，感觉python爬虫挺强大的，然后想到以前看node.js的时候也有相关的用cheerio实现的爬虫，但是太久没接触就忘了。然后最近无聊逛掘金的时候发现了一个叫puppeteer的库，简单了解了之后就跟着一些文章的案例尝试做了几个简单的demo，感觉puppeteer的功能还是很强大的，不仅可以爬取信息，还可以实现模拟点击、输入，截图、打印pdf等功能。 在官方文档中，puppeteer的初始化代码如下: 12345puppeteer.launch().then(async browser =&gt; &#123; const page = await browser.newPage(); await page.goto(\"https://example.com\"); await browser.close();&#125;); 其中launch可以添加比如{headless: false}等参数，headless改成false之后默认打开chromium操作。launch后传入的browser实例通过browser.newPage()来创建一个新的页面，然后通过page.goto(url)打开对应url的标签页，标签页加载完后执行 browser.close()关闭浏览器。 下面来说一下一些在练习过程中用到过的api:page.waitForFunction(pageFunction[, options[, …args]])puppeteer的延时api，通过传入指定数值可以实现延时对应毫秒效果,比如page.waitFor(2000)就是延时2000毫秒，通常用于page.goto()后面来确保页面完全加载，也可以传入选择器或者函数作为参数。 page.$(selector)相当于运行document.querySelector,选择单个元素的选择器，通常搭配比如模拟点击等，参数为空默认返回[] page.$$(selector)相当于运行document.querySelectorAll,选择多个元素的选择器，参数为空返回[] page.click(selector[, options])模拟点击的 api，通过传入指定的选择器可以实现对应选择器的模拟点击。 page.screenshot([options])puppeteer的页面截图api，可以通过传入对应的 options 对象来实现对应的效果，比如page.screenshot({path: &#39;./test.jpg&#39;})就是截图保存到当前目录，截图名字为 test.jpg,除此之外还有以下 options 属性:type: 指定截图类型，比如jpg或者png，默认是pngquality: 截图质量，0-100之间fullpage: 设置为true则截取所有可滚动范围，也就是整个页面clip: 用于设置截图范围，对应的属性有x、y、width、heightomitBackground: 去掉默认白背景，并且允许透明背景截图 page.pdf(options)把页面保存为pdf的api，传入比如{path: &#39;xxx&#39;}就是保存当对应路径，详细参数参考puppeteer 官方文档 page.frames()获取所有frames对象比如iframe，这个 api 是看 cnode 一个爬取网易云音乐歌词评论的爬虫 demo 了解到的，因为网易云用的是iframe所以可以通过这个 api 去爬取对应的iframe。通过page.frames().then(f =&gt; f.name() === &#39;xx&#39;)可以定位到对应的name为 xxx 的iframe。 page.evaluate(pageFunction, …args)用于计算对应选择器里面的相对应的数据，其中第二个参数作为第一个参数的函数所传入的参数。puppeteer 官方文档的例子如下: 12const bodyHandle = await page.$(\"body\");const html = await page.evaluate(body =&gt; body.innerHTML, bodyHandle); 如果单纯用 pageFunction 的话，可以写成: 1234const html = await page.evaluate(() =&gt; &#123; const bodyEle = document.querySelector(\"body\"); return bodyEle.map(v =&gt; v.innerHTML);&#125;); 也可以写成: 123456789const html = await page.evaluate(() =&gt; &#123; let data = []; const bodyEle = document.querySelector(\"body\"); for (ele of eles) &#123; let text = ele.innerHTML; data.push(text); &#125; return data;&#125;); page.$eval(selector, pageFunction[, …args])用于计算单个元素的选择器对应的数据，相当于evaluate传入第二个参数为单选择器。下面用爬取网易云音乐 demo 中的片段作为例子:使用 evaluate 的写法: 1234const LYRIC_SELECTOR = await iframe.$(\"#lyric-content\");const lyricCtn = await iframe.evaluate(e =&gt; &#123; return e.innerText;&#125;, LYRIC_SELECTOR); 使用 page.$eval: 123const lyricCtn = await iframe.$eval(\"#lyric-content\", e =&gt; &#123; return e.innerText;&#125;); 两种写法等价 page.$$eval(selector, pageFunction[, …args])与$eval 的区别是他选择的是多个元素的选择器,同样举爬取网易云 demo 的例子: 123456const commentList = await iframe.$$eval(\".itm\", elements =&gt; &#123; const ctn = elements.map(v =&gt; &#123; return v.innerText.replace(/\\s/g, \"\"); &#125;); return ctn;&#125;); page.close()关闭当前标签页","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://cirnobreak.github.io/tags/Javascript/"},{"name":"爬虫","slug":"爬虫","permalink":"https://cirnobreak.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Vue坑之style设置为scoped后样式无法修改","slug":"VueStyle","date":"2018-03-29T16:00:00.000Z","updated":"2020-03-07T14:02:53.295Z","comments":true,"path":"2018/03/30/VueStyle/","link":"","permalink":"https://cirnobreak.github.io/2018/03/30/VueStyle/","excerpt":"","text":"参考: 知乎专栏下的文章,link 这几天在尝试写一个vue的应用，用到了element-ui这个ui组件库，但是在开发过程中使用element-ui看到一些样式感觉需要修改，手动修改后才发现，改了之后完全没变化，后来才发现是scoped的问题。原本打算修改element-ui下的带验证的el-input在输入后有内容的情况下blur后外边框变成绿色的样式，然后看了下审查元素，找到了.el-form-item.is-success .el-input__inner这个样式，但是，经过简单的修改比如： 123.el-form-item.is-success .el-input__inner &#123; border-color: #dcdfe6;&#125; 完全不起作用，甚至加了!important都无效，后来参考了下知乎专栏下的一篇文章后，改成 123.el-form-item.is-success /deep/ .el-input__inner &#123; border-color: #dcdfe6;&#125; 后就起作用了,还有一种改写方法是把/deep/改成&gt;&gt;&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cirnobreak.github.io/tags/Vue/"},{"name":"踩坑","slug":"踩坑","permalink":"https://cirnobreak.github.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"css世界-流","slug":"流","date":"2018-03-17T16:00:00.000Z","updated":"2020-03-07T14:01:57.807Z","comments":true,"path":"2018/03/18/流/","link":"","permalink":"https://cirnobreak.github.io/2018/03/18/%E6%B5%81/","excerpt":"","text":"参考: 《css 世界》第 3 章 块级元素 常见的块级元素 &lt;div&gt;、&lt;li&gt;、&lt;table&gt; 块级元素 !== display: &quot;block&quot;,&lt;li&gt;的display为list-item,&lt;table&gt;的display为table 块级元素具有换行特性，可以搭配clear来清除浮动 实际开发要么用block要么用table，不用list-item的原因:(1) 1 个字符的比较多，其他都是 5 个字符(2) 不用项目符号的时候要加list-style: none(3) ie 浏览器(包括 IE11),普通元素设置为display: list-item有效但为元素失效 容器盒子(外在与内在盒子)display: block 由外在“块级盒子”与内在”块级盒子容器”组成,可以理解为display: block-blockdisplay: inline-block 由外在”内联盒子”与内在”块级盒子”组成(既能一行显示，又能设置width/height)display: table 可以理解为display: block-tabledisplay: inline-table 可以得到一个文字在一行显示的表格 width: auto 充分利用空间。 &lt;div&gt;、&lt;p&gt;元素的默认宽度是父级容器的100%, display: block默认100%宽度，但是设置width: 100%会出现问题 收缩到最合适。 比如 浮动、绝对定位、inline-block或者table元素。同时这种现象也叫包裹性，指的是元素尺寸由内部元素决定，但永远小于包含块的尺寸，典型的例子就是一个元素是display: inline-block，里面内容再多，只要是正常文本宽度不会超过容器。 收缩到最小。 会出现在table-layout: auto的表格中 超出容器限制。 除非有明确设置width值的时候否则前三种都不会有这种情况。 例外:内容很长或者内联元素设置成white-space: nowrap就会超出容器 包裹性的应用文字少的时候居中，文字多的时候居左 1234&lt;div class=\"box\"&gt; &lt;p id=\"conMore\" class=\"content\"&gt;文字内容&lt;/p&gt; &lt;p&gt;&lt;button id=\"btnMore\"&gt;更多文字&lt;/button&gt;&lt;/p&gt;&lt;/div&gt; 123456789.box &#123; padding: 10px; background-color: #cd0000; text-align: center;&#125;.content &#123; display: inline-block; text-align: left;&#125; 1234567var btn = document.getElementById(\"btnMore\"), content = document.getElementById(\"conMore\");if (btn &amp;&amp; content) &#123; btn.onclick = function() &#123; content.innerHTML = \".新增文字\"; &#125;;&#125; textarea 100%宽度解决方案12345textarea &#123; width: 100%; -ms-box-sizing: border-box; box-sizing: border-box;&#125; 超越!important 的权限min/max-width/height的权限可以覆盖width/height: xxxpx !important比如: 1&lt;img src=\"xxx\" style=\"width: 480px !important;\" /&gt; 123img &#123; max-width: 256px;&#125; 得出的实际宽度是 256px 超越最大当min-width比max-width大的时候会发生冲突，导致min-width有效max-width失效","categories":[{"name":"css","slug":"css","permalink":"https://cirnobreak.github.io/categories/css/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"css","slug":"css","permalink":"https://cirnobreak.github.io/tags/css/"}]},{"title":"React列表&key","slug":"列表&key","date":"2017-11-27T16:00:00.000Z","updated":"2020-03-07T14:01:53.576Z","comments":true,"path":"2017/11/28/列表&key/","link":"","permalink":"https://cirnobreak.github.io/2017/11/28/%E5%88%97%E8%A1%A8&key/","excerpt":"","text":"map()方法遍历数组123456const numbers = [1, 2, 3, 4, 5];const listItem = numbers.map(num =&gt; &#123; return &lt;li&gt;&#123;num&#125;&lt;/li&gt;;&#125;);ReactDOM.render(&lt;ul&gt;&#123;listItem&#125;&lt;/ul&gt;, document.getElementById(\"root\")); 组件写法: 123456789101112function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map(num =&gt; &#123; return &lt;li key=&#123;num.toString()&#125;&gt;&#123;num&#125;&lt;/li&gt;; &#125;); return &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(\"root\")); 用 map 创建时需要给列表元素添加一个 key，最好是独一无二的字符串可以来自数据的 id: 1const todoItems = todos.map(todo =&gt; &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;/li&gt;); 没有确定的 id，用索引 index 作为 key 1const todoItems = todos.map((todo, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;todo.text&#125;&lt;/li&gt;); 用 keys 提取组件12345678910111213141516function ListItem(props) &#123; return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map(num =&gt; ( &lt;ListItem key=&#123;num.toString()&#125; value=&#123;num&#125; /&gt; )); return &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(\"root\"));","categories":[{"name":"JavaScript, React","slug":"JavaScript-React","permalink":"https://cirnobreak.github.io/categories/JavaScript-React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://cirnobreak.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"JSX语法","slug":"JSX语法","date":"2017-11-26T16:00:00.000Z","updated":"2020-03-07T14:02:34.842Z","comments":true,"path":"2017/11/27/JSX语法/","link":"","permalink":"https://cirnobreak.github.io/2017/11/27/JSX%E8%AF%AD%E6%B3%95/","excerpt":"","text":"参考 阮一峰网络日志: React 入门实例教程 基本1234567891011var names = ['aaa', 'bbb', 'ccc'];ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt;hello, &#123;name&#125;!&lt;/div&gt; &#125;); &#125; &lt;/div&gt;, document.getElementById('root')); 等价于: 12345&lt;div&gt; &lt;div&gt;hello, aaa!&lt;/div&gt; &lt;div&gt;hello, bbb!&lt;/div&gt; &lt;div&gt;hello, ccc!&lt;/div&gt;&lt;/div&gt; JSX 基本语法法则: 遇到HTML标签(&lt;开头)就用 HTML 解析，遇到代码块({开头)就用 JavaScript 解析 JSX 允许直接在模板插入 JavaScript 变量，变量如果是数组则会展开12345678var arr = &#123; &lt;h1&gt;Hello World&lt;/h1&gt;, &lt;h2&gt;Hi&lt;/h2&gt;&#125;;ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('root')); 等价于: 1234&lt;div&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;h2&gt;Hi&lt;/h2&gt;&lt;/div&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"React","slug":"React","permalink":"https://cirnobreak.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"React事件处理","slug":"事件处理","date":"2017-11-26T16:00:00.000Z","updated":"2020-03-07T14:02:02.439Z","comments":true,"path":"2017/11/27/事件处理/","link":"","permalink":"https://cirnobreak.github.io/2017/11/27/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"","text":"参考 React 官方文档:事件处理 写法ES5 123456789101112131415var ActionLink = React.createClass(&#123; handleClick: function(e) &#123; e.preventDefault(); console.log(\"hehehe\"); &#125;, render: function() &#123; return ( &lt;a href=\"#\" onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/a&gt; ); &#125;&#125;);ReactDOM.render(&lt;ActionLink /&gt;, document.getElementById(\"root\")); 纯函数 12345678910111213function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log(\"The link was clicked.\"); &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125;ReactDOM.render(&lt;ActionLink /&gt;, document.getElementById(\"root\")); ES6 12345678910111213141516171819class ActionLink extends React.Component&#123; constructor (props) &#123; super(props); &#125; handleClick (e) &#123; e.preventDefault(); console.log('hehehe'); &#125; render () &#123; return ( &lt;a href=\"#\" onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/a&gt; ) &#125;&#125;ReactDOM.(&lt;ActionLink /&gt;, document.getElementById('root')) 开关案例把 this 绑定到回调函数中 123456789101112131415161718192021222324class Toggle extends Component &#123; constructor() &#123; super(); this.state = &#123; isToggleOn: true &#125;; //把this绑定到回调函数 this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? \"ON\" : \"OFF\"&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render(&lt;Toggle /&gt;, document.getElementById(\"root\")); 或者 使用属性初始化器语法 123456789101112131415161718192021222324class Toggle extends Component &#123; constructor() &#123; super(); this.state = &#123; isToggleOn: true &#125;; // 没有了this绑定 &#125; // 改成用箭头函数 handleClick = () =&gt; &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125;; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? \"ON\" : \"OFF\"&#125; &lt;/button&gt; ); &#125;&#125;render(&lt;Toggle /&gt;, document.getElementById(\"root\")); 又或者 回调函数中使用箭头函数 1234567891011121314151617181920212223class Toggle extends Component &#123; constructor() &#123; super(); this.state = &#123; isToggleOn: true &#125;; &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( // 绑定箭头函数 &lt;button onClick=&#123;e =&gt; this.handleClick(e)&#125;&gt; &#123;this.state.isToggleOn ? \"ON\" : \"OFF\"&#125; &lt;/button&gt; ); &#125;&#125;render(&lt;Toggle /&gt;, document.getElementById(\"root\")); 向事件处理程序传递参数两种方式: 12&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 例子: 123456789101112131415161718192021222324252627class Toggle extends Component &#123; constructor() &#123; super(); this.state = &#123; name: \"hello world\" &#125;; &#125; preventPop(name, e) &#123; e.preventDefault(e); alert(name); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &lt;a href=\"www.baidu.com\" onClick=&#123;this.preventPop.bind(this, this.state.name)&#125; &gt; Click &lt;/a&gt; &lt;/div&gt; ); &#125;&#125;render(&lt;Toggle /&gt;, document.getElementById(\"root\"));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"React","slug":"React","permalink":"https://cirnobreak.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"React条件渲染","slug":"条件渲染","date":"2017-11-26T16:00:00.000Z","updated":"2020-03-07T14:02:06.312Z","comments":true,"path":"2017/11/27/条件渲染/","link":"","permalink":"https://cirnobreak.github.io/2017/11/27/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/","excerpt":"","text":"用 if else 逻辑实现一个简单登录逻辑切换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function UserGreeting(props) &#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;;&#125;function GuestGreeting(props) &#123; return &lt;h1&gt;Please sign up.&lt;/h1&gt;;&#125;function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125;function LoginButton(props) &#123; return &lt;button onClick=&#123;props.onClick&#125;&gt;Login&lt;/button&gt;;&#125;function LogoutButton(props) &#123; return &lt;button onClick=&#123;props.onClick&#125;&gt;Logout&lt;/button&gt;;&#125;class LoginControl extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isLoggedIn: false &#125;; this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); &#125; handleLoginClick() &#123; this.setState(&#123; isLoggedIn: true &#125;); &#125; handleLogoutClick() &#123; this.setState(&#123; isLoggedIn: false &#125;); &#125; render() &#123; const isLoggedIn = this.state.isLoggedIn; let button = null; if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;; &#125; return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; ); &#125;&#125;ReactDom.render(&lt;LoginControl /&gt;, document.getElementById(\"root\")); &amp;&amp;运算符12345678910111213141516function MailBox(props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; ( &lt;h2&gt;You have &#123;unreadMessages.length&#125; unread message.&lt;/h2&gt; )&#125; &lt;/div&gt; );&#125;const messages = [\"aaa\", \"bbb\", \"ccc\"];ReactDOM.render( &lt;MailBox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById(\"root\")); xxx1 &amp;&amp; xxx2，如果为真，永远返回第二个(Hello!You have 3 unread message.)，为假则返回第一个(Hello!)， 三目运算符12345678render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125; 阻止渲染让希望隐藏的组件，在渲染的时候让render方法返回null比如根据属性获取 warn(props.warn)的值进行条件渲染，warn为false则不会渲染 1234567891011121314151617181920212223242526272829303132333435function Warning(props) &#123; if (!props.warn) &#123; return null; &#125; return &lt;div className=\"warning\"&gt;Warning!&lt;/div&gt;;&#125;class Page extends React.Component &#123; constructor() &#123; super(); this.state = &#123; showWarning: true &#125;; this.handleToggleClick = this.handleToggleClick.bind(this); &#125; handleToggleClick() &#123; this.setState(prevState =&gt; (&#123; showWarning: !prevState.showWarning &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;Warning warn=&#123;this.state.showWarning&#125; /&gt; &lt;button onClick=&#123;this.handleToggleClick&#125;&gt; &#123;this.state.showWarning ? \"Hide\" : \"Show\"&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Page /&gt;, document.getElementById(\"root\"));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"React","slug":"React","permalink":"https://cirnobreak.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"React生命周期","slug":"状态与生命周期","date":"2017-11-26T16:00:00.000Z","updated":"2020-03-07T14:02:10.780Z","comments":true,"path":"2017/11/27/状态与生命周期/","link":"","permalink":"https://cirnobreak.github.io/2017/11/27/%E7%8A%B6%E6%80%81%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"参考 React 官方文档:State &amp; 生命周期 状态(state)props不可变，但组件要与用户互动，就有了state 12345678910111213var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123; like: false &#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123; liked: !this.state.liked &#125;); &#125;, render: function() &#123; var text = this.state.liked ? \"liked\" : \"haven't liked\"; return &lt;p onClick=&#123;this.handleClick&#125;&gt;You &#123;text&#125; this. Click to toggle.&lt;/p&gt;; &#125;&#125;);ReactDOM.render(&lt;LikeButton /&gt;, document.getElementById(\"root\")); 上面是一个LikeButton组件，getInitialState用于定义初始状态,这个对象可以通过this.state获得，当用户点击组件，状态变化，this.setState方法就修改状态值，每次修改会调用this.render ES6 写法 123456789101112131415161718192021class LikeButton extends React.Component &#123; constructor() &#123; super(); this.state = &#123; liked: false &#125;; &#125; handleClick() &#123; this.setState(&#123; liked: !this.state.liked &#125;); &#125; render() &#123; var text = this.state.liked ? \"liked\" : \"haven't liked\"; return ( &lt;div&gt; &lt;p onClick=&#123;() =&gt; this.handleClick()&#125;&gt;&#123;text&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;render(&lt;LikeButton /&gt;, document.getElementById(\"root\")); 不能通过this.state去直接修改状态，要用this.setState 生命周期当组件在客户端被实例化，第一次被创建时，以下方法依次被调用： getDefaultProps getInitialState componentWillMount(挂载) render componentDidMount(卸载) 通过生命周期钩子函数定义一个时钟应用123456789101112131415161718192021222324class Clock extends React.Component &#123; constructor() &#123; super(); this.state = &#123; date: new Date().toLocaleTimeString() &#125;; &#125; componentDidMount() &#123; this.timmer = setInterval(() =&gt; &#123; this.setState(&#123; date: new Date().toLocaleTimeString() &#125;); &#125;, 1000); &#125; componentWillUnmount() &#123; clearInterval(this.timmer); &#125; render() &#123; return &lt;div&gt;&#123;this.state.date&#125;&lt;/div&gt;; &#125;&#125;render(&lt;Clock /&gt;, document.getElementById(\"root\")); 提取出 tick() 12345678910111213141516171819202122232425class Clock extends React.Component &#123; constructor() &#123; super(); this.state = &#123; date: new Date() &#125;; &#125; componentDidMount() &#123; this.timmer = setInterval(() =&gt; this.tick(), 1000); &#125; componentWillUnmount() &#123; clearInterval(this.timmer); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.date.toLocaleTimeString()&#125;&lt;/div&gt;; &#125;&#125;render(&lt;Clock /&gt;, document.getElementById(\"root\")); 等价于: 123456789101112131415161718192021222324252627var Clock = React.createClass(&#123; getInitialState: function() &#123; return &#123; date: new Date() &#125;; &#125;, componentDidMount: function() &#123; this.timerId = setInterval( function() &#123; this.tick(); &#125;.bind(this), 100 ); &#125;, componentWillUnmount: function() &#123; clearInterval(this.timerId); &#125;, tick: function() &#123; this.setState(&#123; date: new Date() &#125;); &#125;, render: function() &#123; return &lt;div&gt;&#123;this.state.date.toLocaleTimeString()&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;Clock /&gt;, document.getElementById(\"root\")); 状态异步更新React 可以将多个setState()合并成一个。this.props和this.state可以异步更新，不应该依靠他们的值来计算下一个状态。 错误的写法: 123this.setState(&#123; counter: this.state.counter + this.props.increment&#125;); 正确的写法: 123this.setState((prevState, props) =&gt; &#123; counter: prev.counter + props.increment;&#125;); ES5 写法: 123this.setState(function(prevState, props) &#123; return prevState.counter + props.counter;&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"深入JavaScript","slug":"深入JavaScript","permalink":"https://cirnobreak.github.io/tags/%E6%B7%B1%E5%85%A5JavaScript/"}]},{"title":"React组件","slug":"组件","date":"2017-11-26T16:00:00.000Z","updated":"2020-03-07T14:02:14.409Z","comments":true,"path":"2017/11/27/组件/","link":"","permalink":"https://cirnobreak.github.io/2017/11/27/%E7%BB%84%E4%BB%B6/","excerpt":"","text":"组件首字母一定要大写0.14 版开始 React 拆分成 React 跟 ReactDOM参考 React 官方文档组件 创建组件使用 JSX1234567891011121314var Hello = React.createClass(&#123; render: function() &#123; var styleObj = &#123; color: \"red\", fontSize: \"18px\" &#125;; return ( &lt;div className=\"test\" style=&#123;styleObj&#125;&gt; Hello &#123;this.props.name&#125;&#123;\" \"&#125; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render(&lt;Hello name=\"world\" /&gt;, document.getElementById(\"content\")); 因为class是ES6语法糖，所以在元素内声明class要用className,而行内样式style要用对象的形式传入,然后css属性要用小驼峰命名写法 纯函数定义12345function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=\"world\" /&gt;;ReactDOM.render(element, document.getElementById(\"root\")); 输出 Hello, world ES6 的 class 定义123456class Welcome extends React.Component &#123; render () &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;ReactDOM.(&lt;Welcome name=\"world\" /&gt;, document.getElementById('test')); 组件组合通过创建一个App组件多次渲染Welcome组件 123456789101112131415function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name=\"Sara\" /&gt; &lt;Welcome name=\"Cahal\" /&gt; &lt;Welcome name=\"Edite\" /&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\")); 组件提取1234567891011121314151617181920212223242526272829303132333435363738394041function formatDate(date) &#123; return date.toLocaleDateString();&#125;function Avatar(props) &#123; return ( &lt;img className=\"Avatar\" src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt; );&#125;function UserInfo(props) &#123; return ( &lt;div className=\"UserInfo\"&gt; &lt;Avatar user=&#123;props.user&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt;&#123;props.user.name&#125;&lt;/div&gt; &lt;/div&gt; );&#125;function Comment(props) &#123; return ( &lt;div className=\"Comment\"&gt; &lt;UserInfo user=&#123;props.author&#125; /&gt; &lt;div className=\"Comment-text\"&gt;&#123;props.text&#125;&lt;/div&gt; &lt;div className=\"Comment-date\"&gt;&#123;formatDate(props.date)&#125;&lt;/div&gt; &lt;/div&gt; );&#125;const comment = &#123; date: new Date(), text: \"I hope you enjoy learning React!\", author: &#123; name: \"Hello Kitty\", avatarUrl: \"http://placekitten.com/g/64/64\" &#125;&#125;;ReactDOM.render( &lt;Comment date=&#123;comment.date&#125; text=&#123;comment.text&#125; author=&#123;comment.author&#125; /&gt;, document.getElementById(\"root\"));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"React","slug":"React","permalink":"https://cirnobreak.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"css盒模型","slug":"盒模型","date":"2017-11-10T16:00:00.000Z","updated":"2020-03-07T14:01:50.836Z","comments":true,"path":"2017/11/11/盒模型/","link":"","permalink":"https://cirnobreak.github.io/2017/11/11/%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"参考: 《精通 css》第 3 章 W3school: CSS 外边距合并 W3school: CSS 定位 (Positioning) w3plus: CSS3 Box-sizing 盒模型标准盒模型(padding-box): width/height = 内容部分IE 的盒模型(border-box): width/height = 内容部分 + padding * 2 外边距叠加 当一个元素出现在另一个元素的上面时，第一个元素的底外边距与第二个元素的顶外边距发生叠加: 当一个元素包含在另一个元素中时(假设没有内边距或者边框将外边距分隔开),他们的顶或底外边距也会发生叠加: 外边距甚至可以与本身发生叠加。假如有一个空元素，他有外边距，但没有边框或者内边距，在这种情况下，顶外边距与底外边距就碰到一起，会发生叠加: 如果这个外边框碰到另一个元素的外边距，还会发生叠加: 定位一切皆为框div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。把display设置为block可以让行内元素(比如a)变得跟块级元素一样；display设置为none可以让生成的元素没有框，框及其所有内容不再显示，不占用文档空间；把display设置为inline-block可以让元素像行内元素一样水平地依次排列，但框的内容依然符合块级框的行为，例如能够显式地设置宽度、高度、垂直外边距和内边框。 定位机制CSS 中有三种基本定位机制:普通流、浮动和绝对定位。除非专门指定，否则所有框都在普通流定位。行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度 相对定位position设置为relative，通过指定垂直或者水平位置，让这个元素“相对于”他的起点位置移动。比如left设置为20px会在元素左边创建20px的空间，也就是元素向右移动。使用相对定位的时候，无论是否移动，元素仍然占据空间，移动会导致它覆盖其他框。 绝对定位position设置为absolute,相对定位实际上被看做普通流定位模型的一部分，因为元素的位置是相对于它在普通流的位置中。绝对定位使得元素位置与文档流无关，因此不占据空间。普通流文档流中其他元素的布局就像绝对定位的元素不存在时一样。 绝对定位位置的确定相对于距离它最近的那个已定位的祖先元素确定的，如果元素没有已存在的祖先元素，那么它的位置是相对于初始包含块的。根据用户代理不同，初始包含快可能是画布或者 HTML 元素。绝对定位不影响普通流的框，如果扩大绝对定位的框(比如通过增加字号)，周围的框不会重新定位。因此，尺寸的任何改变都会导致绝对定位发生重叠，从而破坏布局。 固定定位position设置为fixed，是绝对定位的一种，差异在于固定元素的包含块是视口(viewport)，即使页面滚动也会一直出现在屏幕的固定位置。 浮动浮动的框可以左右移动，直到他的外边缘碰到包含框或者另一个浮动的框的边缘。因为浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 行框和清除如果浮动元素后面有一个文档流中的元素，那么这个元素的框会表现得像浮动一样根本不存在一样。但是，框的文本内容会受到浮动元素的影响，会移动以留出空间。实际上，创建浮动框使文本可以围绕图像。想要阻止行框围绕在浮动框的外边，需要对元素设置clear属性。clear属性的值可以是left、right、both或者none。因为浮动元素不占据空间，所以容器元素不能包含他们。添加一个进行清空的空元素(设置clear)可以迫使容器元素包围浮动元素(撑大)。 使用伪类清除浮动一些人使用 CSS 生成的内容或者 JavaScript 对浮动元素进行清理。对于这两种方法，需要指定清理的元素应该出现在哪里，通常需要加一个类名，比如: 1234&lt;div class=\"news clear\"&gt; &lt;img src=\"xx.jpg\" alt=\"\" /&gt; &lt;p&gt;Some text&lt;/p&gt;&lt;/div&gt; 结合使用:after 伪类和内容声明在指定的现有内容的末尾添加内容。假如，不希望新内容占据垂直空间或者在页面上显示，需要将 height 设置为 0，将 visibility 设置为 hidden，因为被清理的元素在他们的顶外边距添加了空间，所以生成的内容需要将它的 display 设置为 block。 1234567.clear:after &#123; content: \"\"; height: 0; visibility: hidden; display: block; clear: both;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://cirnobreak.github.io/categories/css/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"css","slug":"css","permalink":"https://cirnobreak.github.io/tags/css/"}]},{"title":"css选择器","slug":"选择器","date":"2017-11-10T16:00:00.000Z","updated":"2020-03-07T14:02:08.332Z","comments":true,"path":"2017/11/11/选择器/","link":"","permalink":"https://cirnobreak.github.io/2017/11/11/%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"参考 《精通 css》 第 2 章segmentfault: 详解 css3 系列：伪元素和伪类选择器 伪类选择器:hover、:link、:active、:target、:not(s)、:focus等 结构性伪类选择器 四个最基本的：root、not、empty、target first-child、last-child、nth-child、nth-last-child、nth-child(odd)、nth-child(even)、nth-last-child(odd)、nth-last-child(even) nth-of-type、nth-last-of-type 循环使用样式 only-child UI 状态元素伪类选择器E:checked、E:enabled、E:disabled、E::selection #伪元素选择器:first-line、:first-letter、:before、after、::selection,css3中的伪元素选择器用::xx 表示 优先级行内样式:style - 1000id 选择器: #xx - 100类、伪类、属性选择器: .xx、.xx:hover、.xx[title=&#39;xxx&#39;] - 10类型选择器、伪元素选择器: p、div 、:before - 1做加法运算!important 优先级最高特例:min/max-width/height的权限可以覆盖width/height: xxxpx !important 继承继承就是应用样式的元素的后代会继承样式的某些属性，比如颜色和字号。比如设置了body {color: black;}后代字体都是黑色。","categories":[{"name":"css","slug":"css","permalink":"https://cirnobreak.github.io/categories/css/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"css","slug":"css","permalink":"https://cirnobreak.github.io/tags/css/"}]},{"title":"JavaScript之作用域","slug":"作用域","date":"2017-11-08T16:00:00.000Z","updated":"2020-03-07T14:02:19.336Z","comments":true,"path":"2017/11/09/作用域/","link":"","permalink":"https://cirnobreak.github.io/2017/11/09/%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"参考: 《你不知道的 JavaScript part1 第 1 章》 编译原理三个步骤 分词/词法分析: 比如var a = 2会被分解成var、a、=、2、;这些都是词法单元 解析/语法分析:这个过程是将词法单元流（数组） 转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。 这个树被称为”抽象语法树(AST)” 代码生成把 AST 转成可执行代码的过程 JavaScript 编译的不同点 在词法分析跟代码生成有特定步骤优化 引擎不会有大量时间进行优化 大部分编译发生在代码执行前几微秒 JavaScript 编译成员引擎、编译器、作用域var a = 2; 的编译过程 编译器遇到var a时会寻找是否存在同名变量在同一作用域，有就忽略，没有就声明新变量a 引擎访问作用域是否有a,有就使用，没有则继续查找 如果引擎找到就赋2的给他，否则就抛出异常总结: 赋值会有两个动作，编译器在当前作用域声明变量，然后引擎在该作用域查找改变量，找到则赋值。 编译器的查询–LHS、RHS 查询LHS–赋值操作目标 RHS–复制操作源头123456console.log(a); //RHSa = 2; //LHSfunction (a) &#123; console.log(a); //2, 进行了a = 2的操作，LHS&#125;foo(2); //RHS，找foo的值 作用域嵌套12345function foo(a) &#123; console.log(a + b);&#125;var b = 2;foo(2); // 4","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"深入JavaScript","slug":"深入JavaScript","permalink":"https://cirnobreak.github.io/tags/%E6%B7%B1%E5%85%A5JavaScript/"}]},{"title":"JavaScript之对象","slug":"对象","date":"2017-11-08T16:00:00.000Z","updated":"2020-03-07T14:01:47.164Z","comments":true,"path":"2017/11/09/对象/","link":"","permalink":"https://cirnobreak.github.io/2017/11/09/%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"参考: 《你不知道的 JavaScript part2 第 3 章》 JavaScript 类型一共六种主要类型:string、number、boolean、null、undefined、object，不过typeof null会返回object，但null本身是基本类型 内置对象JavaScript 中的对象子类型，被称作内置对象:String、Number、Boolean、Object、Function、Array、Date、RegExp、Errornull 和 undefined 没有对应的构造形式， 它们只有文字形式。 相反， Date 只有构造， 没有文字形式。对于 Object、 Array、 Function 和 RegExp（正则表达式） 来说， 无论使用文字形式还是构造形式， 它们都是对象， 不是字面量。 复制对象1234567891011121314function anotherFunction() &#123; /*..*/&#125;var anotherObject = &#123; c: true&#125;;var anotherArray = [];var myObject = &#123; a: 2, b: anotherObject, // 引用， 不是复本！ c: anotherArray, // 另一个引用！ d: anotherFunction&#125;;anotherArray.push(anotherObject, myObject); 如何判断是深拷贝还是浅拷贝？浅拷贝: 复制出的新对象的 a 的值会复制就对象 a 的值，但新对象中 b、c、d 三个属性是三个引用，和旧对象 b、c、d 引用的对象是一样的。深拷贝: 除了复制 myObject 以外还会复制 anotherObject 和 anotherArray es6 的浅拷贝: 12345var newObj = Object.assign(&#123;&#125;, myObject);newObj.a; // 2newObj.b === anotherObject; // truenewObj.c === anotherArray; // truenewObj.d === anotherFunction; // true Object.assign()方法的第一个参数是目标对象，之后可以跟一个或者多个源对象 属性描述符从es5开始所有属性符都具备了属性描述符。 Object.getOwnPropertyDescriptor() 12345678910var myObject = &#123; a: 2&#125;;Object.getOwnPropertyDescriptor(myObject, \"a\");// &#123;// value: 2,// writable: true,// enumerable: true,// confgurable: true// &#125; writable（可写）、enumerable（可枚举） 和 configurable（可配置） Object.defineProperty() writable：决定是否可以修改属性的值 123456789var myObject = &#123;&#125;;Object.defineProperty(myObject, \"a\", &#123; value: 2, writable: false, // 不可写！ configurable: true, enumerable: true&#125;);myObject.a = 3;myObject.a; // 2 writable为false的时候，myObject.a修改失败。在严格模式下，这种方法会出错:javascript &quot;use strict&quot;; var myObject = {}; Object.defineProperty( myObject, &quot;a&quot;, { value: 2, writable: false, // 不可写！ configurable: true, enumerable: true }); myObject.a = 3; // TypeErrorTypeError提示无法修改一个不可写的属性 configurable:只要属性是 configurable 就可以使用 Object.defineProperty()来修改属性描述符。 12345678910111213141516171819202122232425262728293031323334353637383940var myObject = &#123; a:2&#125;;myObject.a = 3;myObject.a; // 3Object.defineProperty( myObject, \"a\", &#123; value: 4, writable: true, configurable: false, // 不可配置！对象 ｜ 113 enumerable: true&#125;);myObject.a; // 4myObject.a = 5;myObject.a; // 5Object.defineProperty( myObject, \"a\", &#123; value: 6, writable: true, configurable: true, enumerable: true&#125;); // TypeError`无论是否在严格模式，修改一个`configurable: false`的属性描述符都会出错，可看出`configurable: false`是单向操作，无法撤销注:即便属性是 `configurable:false`， 我们还是可以把 `writable` 的状态由 `true` 改为 `false`， 但是无法由 `false` 改为 `true`。```javascriptvar myObject = &#123; a:2&#125;;myObject.a; // 2delete myObject.a;myObject.a; // undefinedObject.defineProperty( myObject, \"a\", &#123; value: 2, writable: true, configurable: false, enumerable: true&#125;);myObject.a; // 2delete myObject.a;myObject.a; // 2 除了无法修改， configurable:false 还会禁止删除这个属性 enumerableenumerable为false的时候，这个属性不会被枚举，比如for...in循环不能用 不变性 对象常量结合writable: false跟configurable: false就可以真正创建一个常量(不可修改、定义、或者删除) 123456var myObject = &#123;&#125;;Object.defineProperty(myObject, \"FAVORITE_NUMBER\", &#123; value: 42, writable: false, configurable: false&#125;); 禁止扩展用Object.preventExtensions(),禁止添加新属性，并保留已有属性 123456var myObject = &#123; a: 2&#125;;Object.preventExtensions(myObject);myObject.b = 3;myObject.b; // undefined 在严格模式下，会抛出TypeError 密封用Object.seal()会常见一个“密封”的对象，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性 冻结Object.freeze()会创建一个冻结对象，实际上会在一个现有对象上调用Object.seal()并把所有“数据访问”属性标记为writable:false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"深入JavaScript","slug":"深入JavaScript","permalink":"https://cirnobreak.github.io/tags/%E6%B7%B1%E5%85%A5JavaScript/"}]},{"title":"JavaScript之this","slug":"this","date":"2017-11-07T16:00:00.000Z","updated":"2020-03-07T14:02:47.152Z","comments":true,"path":"2017/11/08/this/","link":"","permalink":"https://cirnobreak.github.io/2017/11/08/this/","excerpt":"","text":"参考: 《你不知道的 JavaScript part2 第 1、2 章》 this 初步理解当函数被调用时，会创建一个活动记录(上下文)，这个记录包括函数在哪被调用(调用栈)、函数调用方法、传入参数等信息，this就是记录其中的一个属性误解：this指向函数自身，this指向函数函数的词法作用域。而实际上，this是在函数被调用时发生的绑定，他的指向取决于函数在哪被调用 this 的绑定规则默认绑定12345function foo() &#123; console.log(this.a);&#125;var a = 2;foo(); // 2 在调用foo()的时候this.a被解析成全局变量a，因为此时应用了 this 的默认绑定指向了全局为什么是默认绑定？因为foo()直接使用是不带任何修饰的函数进行引用调用，因此只能用默认绑定而不能用其他规则 123456function foo() &#123; \"use strict\"; console.log(this.a);&#125;var a = 2;foo(); // TypeError: this is undefined 使用了严格模式后，全局对象无法使用默认绑定，this会被绑定到 undefined 12345678function foo() &#123; console.log(this.a);&#125;var a = 2;(function() &#123; \"use strict\"; foo(); // 2&#125;)(); 严格模式与foo的调用位置无关 隐式绑定12345678function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); // 2 严格来说foo()不属于obj，但这个调用位置会使用 obj 上下文去引用foo()。当函数引用有上下文对象的时候，隐式绑定会把this绑定到这个上下文 123456789101112function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo: foo&#125;;var obj1 = &#123; a: 2, obj2: obj2&#125;;obj1.obj2.foo(); // 42 对象引用层只有最顶层或者最后一层会影响其调用位置 隐式丢失12345678910function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数别名！var a = \"oops, global\"; // a 是全局对象的属性bar(); // \"oops, global\" 虽然bar是obj.foo的一个引用，但实际上引用的是foo函数的本身，此时的bar是一个不带任何修饰的绑定，应用了默认绑定 在传入回调函数的时候也会失去绑定： 123456789101112131415161718192021222324252627282930例子1:function foo() &#123; console.log( this.a );&#125;function doFoo(fn) &#123; // fn 其实引用的是 foo fn(); // &lt;-- 调用位置！&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = \"oops, global\"; // a 是全局对象的属性doFoo( obj.foo ); // \"oops, global\"例子2:function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = \"oops, global\"; // a 是全局对象的属性setTimeout( obj.foo, 100 ); // \"oops, global\"实际上的`setTimeout`：function setTimeout(fn,delay) &#123; // 等待 delay 毫秒 fn(); // &lt;-- 调用位置！&#125; 总结： 回调函数丢失this的绑定很常见，调用回调函数的函数也可能会修改this 显式绑定使用call()或者apply()方法实现，他们的第一个参数是一个对象，他们会把这个对象绑定到这个this，在调用函数的时候指定这个this，就可以指定 this 的绑定对象，这就是显式绑定。 1234567function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); // 2 通过foo.call(),调用时foo强制把this绑定到obj上，如果传入一个原始值(boolean、String、Number)当做this的绑定对象，这个原始值会被转成他的对象形式(new Boolean()、new String()、new Number()) 硬绑定显式绑定仍然无法解决绑定丢失，但显式绑定变种(硬绑定)可以解决 12345678910111213function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; foo.call(obj);&#125;;bar(); // 2setTimeout(bar, 100); // 2// 硬绑定的 bar 不可能再修改它的 thisbar.call(window); // 2 如何运行？ 先创建函数bar()，并在内部手动调用foo.call(obj),强制把foo的this绑定到obj,之后无论如何调用bar都会在obj上调用foo 硬绑定的应用场景就是创建一个包装函数，传入所有参数并返回所有收到的值。例子: 123456789101112function foo(something) &#123; console.log(this.a, something); return this.a + something;&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; return foo.apply(obj, arguments);&#125;;var b = bar(3); // 2 3console.log(b); // 5 另一种就是创建一个可以重复利用的辅助函数，例子: 12345678910111213141516function foo(something) &#123; console.log(this.a, something); return this.a + something;&#125;// 简单的辅助绑定函数function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;;&#125;var obj = &#123; a: 2&#125;;var bar = bind(foo, obj);var b = bar(3); // 2 3console.log(b); // 5 ES5提供了内置方法Function.prototype.bind实现硬绑定，会把参数设置为this的执行上下文并调用原始函数，例子: 12345678910function foo(something) &#123; console.log(this.a, something); return this.a + something;&#125;var obj = &#123; a: 2&#125;;var bar = foo.bind(obj);var b = bar(3); // 2 3console.log(b); // 5 new 绑定使用new来调用函数会发生下列操作: 创建（或者说构造）一个全新的对象。 这个新对象会被执行原型连接。 这个新对象会绑定到函数调用的 this。 如果函数没有返回其他对象， 那么 new 表达式中的函数调用会自动返回这个新对象。 12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); // 2 此时，会构造一个新对象并把它绑定到foo()中调用的this上。 优先级123456789101112131415function foo() &#123; console.log(this.a);&#125;var obj1 = &#123; a: 2, foo: foo&#125;;var obj2 = &#123; a: 3, foo: foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2 从这里可以看出显式绑定优先级高于隐式绑定 1234567891011121314function foo(something) &#123; this.a = something;&#125;var obj1 = &#123; foo: foo&#125;;var obj2 = &#123;&#125;;obj1.foo(2);console.log(obj1.a); // 2obj1.foo.call(obj2, 3);console.log(obj2.a); // 3var bar = new obj1.foo(4);console.log(obj1.a); // 2console.log(bar.a); // 4 从这里可以看出 new 绑定比隐式绑定优先级高 12345678910function foo(something) &#123; this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind(obj1);bar(2);console.log(obj1.a); // 2var baz = new bar(3);console.log(obj1.a); // 2console.log(baz.a); // 3 bar被硬绑定到obj1上，但new Bar(3)并没有把obj1.a修改为 3，反而new修改了硬绑定调用bar()的this，使用new绑定后得到baz的新对象，baz.a的值为3 部分应用化(柯里化的一种)bind()功能之一:把除了第一个参数外的其他参数传给下层函数,这种叫做部分应用化 1234567function foo(p1, p2) &#123; this.val = p1 + p2;&#125;// 使用 new 时 this 会被修改var bar = foo.bind(null, \"p1\");var baz = new bar(\"p2\");baz.val; // p1p2 总结如何判断 this 函数在new中调用(new绑定) =&gt; this绑定指定对象 1var bar = new foo(); 函数通过call、apply(显示绑定)或者硬绑定 =&gt; this绑定的是指定的对象 1var bar = foo.call(obj); 函数在某个上下文中调用 =&gt; this绑定那个上下文对象 1var bar = obj.foo(); 都不是，则是默认绑定。严格模式绑定到undefined，否则绑定到全局对象。 1var bar = foo(); 特殊绑定被忽略的 this12345function foo() &#123; console.log(this.a);&#125;var a = 2;foo.call(null); // 2 把 null、undefined 传入 apply、call、bind 在调用时会被忽略而变成默认绑定 null 的作用: 1234567function foo(a, b) &#123; console.log(\"a:\" + a + \", b:\" + b);&#125; // 把数组“展开” 成参数foo.apply(null, [2, 3]); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind(null, 2);bar(3); // a:2, b:3 间接引用12345678function foo() &#123; console.log(this.a);&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;;var p = &#123; a: 4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 p.foo = o.foo实际返回的是目标函数的引用，因此调用位置是foo()而不是p.foo()或者o.foo(),这里会启动默认绑定注:对默认绑定来说，决定 this 绑定对象的不是调用位置而是函数体是否处于严格模式，如果是就绑定 undefined,否则绑定到全局对象 箭头函数 this 的词法123456789101112131415function foo() &#123; // 返回一个箭头函数 return a =&gt; &#123; //this 继承自 foo() console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3100&#125;;var bar = foo.call(obj1);bar.call(obj2); // 2, 不是 3 ！ foo()创建箭头函数的时候捕获调用 foo 的时候的 this,由于 foo()的 this 绑定到 obj1,bar 的 this 也会被绑定到 obj1，箭头函数的绑定无法修改 箭头函数常用于回调函数: 12345678910function foo() &#123; var self = this; // lexical capture of this setTimeout(function() &#123; console.log(self.a); &#125;, 100);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); // 2 等价于: 12345678910function foo() &#123; var self = this; // lexical capture of this setTimeout(function() &#123; console.log(self.a); &#125;, 100);&#125;var obj = &#123; a: 2&#125;;foo.call(obj); // 2","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"深入JavaScript","slug":"深入JavaScript","permalink":"https://cirnobreak.github.io/tags/%E6%B7%B1%E5%85%A5JavaScript/"}]},{"title":"JavaScript之变量提升","slug":"变量提升","date":"2017-11-07T16:00:00.000Z","updated":"2020-03-07T14:01:45.158Z","comments":true,"path":"2017/11/08/变量提升/","link":"","permalink":"https://cirnobreak.github.io/2017/11/08/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","excerpt":"","text":"参考: 《你不知道的 JavaScript part1 第 3 章》 变量提升原理引擎在解析 JavaScript 代码之前，需要编译器先编译，而编译阶段就是先找到所有声明，并用合适的作用域把他们关联起来 1234567891011121314151617//第一个例子:a = 2;var a;console.log(a); //输出2//过程:var a; //编译，变量提升a = 2; //执行console.log(a); //2//第二个例子:console.log(a); //undefinedvar a = 2;//过程:var a; //编译，变量提升a = 2; //执行 总结:先有(编译器)声明后有(引擎)赋值 函数声明与函数表达式的提升12345678910111213141516171819202122232425262728293031323334353637383940//函数声明:foo(); //undefinedfunction foo() &#123; var a; console.log(a); //undefined a = 2;&#125;//实际上:function foo() &#123; var a; console.log(a); a = 2;&#125;foo();//函数表达式:foo(); //不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123; // ...&#125;;//结合的情况:foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() &#123; // ...&#125;;//实际上:var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() &#123;var bar = ...self... // ...&#125; 总结: 函数声明会被提升，但函数表达式不会被提升，即使是具名的函数表达式，名称标识符在赋值之前也无法在作用域中使用 函数优先123456789101112131415161718//例子:foo(); // 1var foo;function foo() &#123; console.log(1);&#125;foo = function() &#123; console.log(2);&#125;;//实际上:function foo() &#123; console.log(1);&#125;foo(); // 1foo = function() &#123; console.log(2);&#125;; 后面的函数可以覆盖掉前面的1234567891011//例子:foo(); // 3function foo() &#123; console.log(1);&#125;var foo = function() &#123; console.log(2);&#125;;function foo() &#123; console.log(3);&#125; 避免在块内部声明函数，比如在条件判断语句中会被提升到作用域顶部1234567891011foo(); // \"b\"var a = true;if (a) &#123; function foo() &#123; console.log(\"a\"); &#125;&#125; else &#123; function foo() &#123; console.log(\"b\"); &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cirnobreak.github.io/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://cirnobreak.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"深入JavaScript","slug":"深入JavaScript","permalink":"https://cirnobreak.github.io/tags/%E6%B7%B1%E5%85%A5JavaScript/"}]}]}